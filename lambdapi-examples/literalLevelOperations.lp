require open Stdlib.Set Stdlib.Prop Stdlib.FOL Stdlib.Eq Stdlib.Nat 
Stdlib.Bool Stdlib.List Stdlib.Impred;

///////////////////////////////////////////////////////////////////////
//////////////////////// ENCODINGS ////////////////////////////////////
///////////////////////////////////////////////////////////////////////

// literals 
// (defined by nth âŠ¥) returns the literal at a given index of a 
// list of literals
symbol literal â‰” nth âŠ¥;

// nths
// Takes a list of natural numbers and a list of objects of type a,
// and returns a new list where the objects are reordered according
// to the sequence of natural numbers.
symbol nths [a : Set] : Ï„ a â†’ ğ•ƒ a â†’ ğ•ƒ nat â†’ ğ•ƒ a;
rule nths $b $l $n â†ª map (nth $b $l) $n;
symbol literals â‰” nths âŠ¥;

// disj
// Takes a list of terms of type o and returns a disjunction of the
// given terms.
symbol disj : ğ•ƒ o â†’ Ï„ o;
rule disj ($l1 â¸¬ ($c â¸¬ $l)) â†ª ($l1 âˆ¨ disj ($c â¸¬ $l))
with disj ($l1 â¸¬ â–¡) â†ª $l1 
with disj â–¡ â†ª âŠ¥;

// âŠ†
// Takes a computable equality relation on type a and two lists of type a
// and returns true if the first list in included in the second, false
// otherwise
symbol âŠ†  [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;
rule âŠ† $beq ($k0 â¸¬ $k) $l â†ª (âˆˆ $beq $k0 $l) and (âŠ† $beq $k $l)
with âŠ† _ â–¡ _ â†ª true;
// âŠ†â‚™ (defined with respect to âŠ†)
symbol âŠ†â‚™ â‰” âŠ† eqn;
notation âŠ†â‚™ infix right 30.000000;

// âˆˆâ‚™ (defined with respect to âˆˆ)
symbol âˆˆâ‚™ â‰” âˆˆ eqn;
notation âˆˆâ‚™ infix right 30.000000;

// preserves_contents
// Takes a list of terms of type o and a list of natural numbers and returns 
// true if the indices of the list of terms of type o are include  in the list
// of natural numbers
symbol preserves_contents: ğ•ƒ nat â†’ ğ•ƒ o â†’ ğ”¹;
rule preserves_contents  $f $l â†ª (indexes $l) âŠ†â‚™ $f;


///////////////////////////////////////////////////////////////////////
//////////////////////// PROOFS ///////////////////////////////////////
///////////////////////////////////////////////////////////////////////

opaque symbol literal_ext (l: ğ•ƒ o) (l0 : Ï„ o) (n: Ï„ nat) : 
    Ï€ (literal l n) â†’ Ï€ (literal (l0 â¸¬ l) (n +1)) â‰”
begin
    assume l l0 n;
    assume h1;
    refine h1
end;

opaque symbol disj_head (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (l0) â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine h1}   
        {assume x0 l1 h1; 
        assume h2; 
        refine âˆ¨áµ¢â‚ h2}
end; 

opaque symbol disj_tail (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (disj l) â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume x1 l1 h1 h2;
        refine âˆ¨áµ¢â‚‚ h2}
end;

opaque symbol disj_correct (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (disj (l0 â¸¬ l)) â†’ Ï€ (l0 âˆ¨ disj l) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine âˆ¨áµ¢â‚ h1}
        {assume x1 l1 h1 h2;
        refine h2}
end;

opaque symbol lit_imp_disj_pos (c: ğ•ƒ o) (ks: ğ•ƒ nat) : 
    Ï€ (`âˆƒ x, (literal c x) âˆ§ (x âˆˆâ‚™ ks)) â†’ Ï€ (disj (literals c ks)) â‰”
begin
    assume c;
    induction
        {simplify;
        assume h1;
        have H0: (Î  x: Ï„ nat, Ï€ ((Î» x1, literal c x1 âˆ§ âŠ¥) x) â†’ Ï€ âŠ¥)
            {assume x h2;
            refine âˆ§â‚‘â‚‚ h2};
        refine âˆƒâ‚‘ h1 H0}
        {assume n l;
        simplify;
        assume h1 h2;
        have H1 : Î  x: Ï„ nat, Ï€ ((Î» x1, literal c x1 âˆ§ (eqn x1 n or x1 âˆˆâ‚™ l)) x) â†’ Ï€ (disj (literal c n â¸¬ literals c l))
            {assume m h3;
            have H0 : Ï€ ((eqn m n) âˆ¨ (m âˆˆâ‚™ l))
                {refine âˆ¨_istrue [eqn m n] [m âˆˆâ‚™ l] (âˆ§â‚‘â‚‚ h3)};
            have H1 : Ï€ (eqn m n) â†’ Ï€ (disj (literal c n â¸¬ literals c l))
                {assume h4;
                have H1_0 : Ï€ (literal c n)
                    {have H1_0_0 : Ï€ (n = m)
                        {symmetry;
                        refine eqn_correct m n h4};
                    rewrite H1_0_0;
                    refine âˆ§â‚‘â‚ h3};
                refine disj_head (literal c n) (literals c l) H1_0};
            have H2 : Ï€ (m âˆˆâ‚™ l) â†’ Ï€ (disj (literal c n â¸¬ literals c l))
                {assume h4;
                have H2_0 : Ï€ `âˆƒ x, literal c x âˆ§ (x âˆˆâ‚™ l)
                    {have H2_0_0 : Ï€ ((Î» x, literal c x âˆ§ (x âˆˆâ‚™ l)) m)
                        {refine âˆ§áµ¢ (âˆ§â‚‘â‚ h3) h4};
                    refine âˆƒáµ¢ m H2_0_0};
                refine disj_tail (literal c n) (literals c l) (h1 H2_0)};
            refine âˆ¨â‚‘ H0 H1 H2
            };
        refine âˆƒâ‚‘ h2 H1}   
end;

opaque symbol disj_imp_lit (l: ğ•ƒ o) : 
    Ï€ (disj l) â†’ Ï€ (`âˆƒ (x : Ï„ nat), (literal l x) âˆ§ (x âˆˆâ‚™ (indexes l))) â‰”
begin
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume l0 l h1 h2;
        have H0: Ï€ (l0 âˆ¨ disj l)
            {refine disj_correct l0 l h2};
        have H1: Ï€ l0 â†’ Ï€ (`âˆƒ x, (literal (l0 â¸¬ l) x) âˆ§ (x âˆˆâ‚™ (indexes (l0 â¸¬ l))))
            {assume h3;
            have H1_0 : Ï€ (literal (l0 â¸¬ l) 0)
                {simplify;
                refine h3};
            have H1_1 : Ï€ ((Î» x, literal (l0 â¸¬ l) x âˆ§ (x âˆˆâ‚™ (indexes (l0 â¸¬ l)))) 0)
                {simplify;
                refine âˆ§áµ¢ H1_0 (0âˆˆindexesâ¸¬ l0 l)};
            refine âˆƒáµ¢ [nat] [(Î» x, literal (l0 â¸¬ l) x âˆ§ (x âˆˆâ‚™ (indexes (l0 â¸¬ l))))] 0 H1_1};
        have H2: Ï€ (disj l) â†’ Ï€ (`âˆƒ x, (literal (l0 â¸¬ l) x) âˆ§ (x âˆˆâ‚™ (indexes (l0 â¸¬ l))))
            {assume h3;
            have H2_0 : Î  x0 , Ï€ ((Î» x, literal l x âˆ§ (x âˆˆâ‚™(indexes l))) x0) â†’ Ï€ (`âˆƒ x, (literal (l0 â¸¬ l) x) âˆ§ (x âˆˆâ‚™ (indexes (l0 â¸¬ l))))
                {assume n h4;
                have H2_0_0 : Ï€ ((Î» x , (literal (l0 â¸¬ l) x) âˆ§ (x âˆˆâ‚™(indexes (l0 â¸¬ l)))) (n +1))
                    {refine âˆ§áµ¢ (literal_ext l l0 n ((âˆ§â‚‘â‚ h4))) (+1âˆˆindexesâ¸¬ o n l l0 ((âˆ§â‚‘â‚‚ h4)))};
                refine âˆƒáµ¢ [nat] [Î» x , (literal (l0 â¸¬ l) x) âˆ§ (x âˆˆâ‚™(indexes (l0 â¸¬ l)))] (n +1) H2_0_0
                };
            refine âˆƒâ‚‘ (h1 h3) [`âˆƒ x, (literal (l0 â¸¬ l) x) âˆ§ (x âˆˆâ‚™(indexes (l0 â¸¬ l)))] H2_0};
        refine âˆ¨â‚‘ H0 H1 H2};
end;

opaque symbol x_in_xâ¸¬ [a] (l: ğ•ƒ a) (l0 : Ï„ a) (beq: Ï„ a â†’ Ï„ a â†’ ğ”¹) : 
    (Î  x, Ï€ (beq x x)) â†’ Ï€ (âˆˆ beq l0 (l0 â¸¬ l)) â‰”
begin
    assume a l l0 beq h1;
    type mem_head beq l0 l;
    type h1 l0;
    print istrue;
    refine oráµ¢â‚ [beq l0 l0] (âˆˆ beq l0 l) (h1 l0)
end;

opaque symbol mem_tail [a] (beq: Ï„ a â†’ Ï„ a â†’ ğ”¹) (n m: Ï„ a) (l: ğ•ƒ a) : 
    Ï€ (âˆˆ beq n l) â†’ Ï€ (âˆˆ beq n (m â¸¬ l)) â‰”
begin
    assume a beq n m;
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume n0 l;
        assume h1 h2;
        have H0: Ï€ (beq n n0) â†’  Ï€ (beq n m or (beq n n0 or âˆˆ beq n l))
            {assume h3;
            refine oráµ¢â‚‚ (beq n m) [beq n n0 or âˆˆ beq n l] (oráµ¢â‚ [beq n n0] (âˆˆ beq n l) h3)};
        have H1: Ï€ (âˆˆ beq n l) â†’  Ï€ (beq n m or (beq n n0 or âˆˆ beq n l))
            {assume h3;
            refine oráµ¢â‚‚ (beq n m) [beq n n0 or âˆˆ beq n l] (oráµ¢â‚‚ (beq n n0) [âˆˆ beq n l] h3)};
        refine orâ‚‘ [beq n n0] [âˆˆ beq n l] (beq n m or (beq n n0 or âˆˆ beq n l)) h2 H0 H1}
end;

opaque symbol disj_imp_lit_pos (c: ğ•ƒ o) (ks: ğ•ƒ nat): 
    Ï€ (disj (literals c ks)) â†’ Ï€ (`âˆƒ (x : Ï„ nat), (literal c x) âˆ§ (x âˆˆâ‚™ ks)) â‰”
begin
    assume c;
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume l0 ks;
        assume h1 h2;
        have H0: Ï€ ((literal c l0) âˆ¨ disj (literals c ks))
            {refine disj_correct (literal c l0) (literals c ks) h2};
        have H1: Ï€ (literal c l0) â†’ Ï€ (`âˆƒ x, literal c x âˆ§ (x âˆˆâ‚™(l0 â¸¬ ks)))
            {assume h3;
            have H1_0 : Ï€ (literal c l0)
                {refine h3};
            have H1_1 : Ï€ ((Î» x, literal  c x âˆ§ (x âˆˆâ‚™(l0 â¸¬ ks))) l0)
                {type mem_head eqn l0 ks;
                type eqn_complete l0 l0 (eq_refl l0);
                compute istrue (eqn l0 l0);
                type (Î» x, (eqn_complete x x (eq_refl x)));
                type x_in_xâ¸¬ ks l0 eqn (Î» x, (eqn_complete x x (eq_refl x)));
                refine âˆ§áµ¢ H1_0 (x_in_xâ¸¬ ks l0 eqn (Î» x, (eqn_complete x x (eq_refl x))))};
        refine âˆƒáµ¢ [nat] [Î» x, literal c x âˆ§ (x âˆˆâ‚™(l0 â¸¬ ks))] l0 H1_1};
        have H2: Ï€ (disj (literals c ks)) â†’ Ï€ (`âˆƒ x, literal c x âˆ§ (x âˆˆâ‚™(l0 â¸¬ ks)))
            {assume h3;
            have H2_0: (Î  x: Ï„ nat, Ï€ ((Î» x1, literal c x1 âˆ§ (x1 âˆˆâ‚™ ks)) x) â†’ Ï€ (`âˆƒ x1, literal c x1 âˆ§ (x1 âˆˆâ‚™ (l0 â¸¬ ks))))
                {assume n h4;
                have H2_0_0 : Ï€ ((Î» x, literal c x âˆ§ (x âˆˆâ‚™(l0 â¸¬ ks))) n)
                    {refine âˆ§áµ¢ (âˆ§â‚‘â‚ h4) (mem_tail eqn n l0 ks (âˆ§â‚‘â‚‚ h4))};
                refine âˆƒáµ¢ [nat]  [Î» x , literal c x âˆ§ (x âˆˆâ‚™(l0 â¸¬ ks))] n H2_0_0};
            refine âˆƒâ‚‘ (h1 h3) [`âˆƒ x, literal c x âˆ§ (x âˆˆâ‚™(l0 â¸¬ ks))] H2_0};    
        refine âˆ¨â‚‘ H0 H1 H2}
end;

opaque symbol âŠ†_el (n: Ï„ nat) (Ïƒ: ğ•ƒ nat) (ln: ğ•ƒ nat): 
    Ï€ (ln âŠ†â‚™ Ïƒ) â†’ Ï€ (n âˆˆâ‚™ ln) â†’ Ï€ (n âˆˆâ‚™ Ïƒ) â‰”
begin
    assume n Ïƒ;
    induction
        {assume h1 h2;
        refine âŠ¥â‚‘ h2}
        {assume m ln h1 h2 h3;
        have H1: Ï€ (eqn n m) â†’ Ï€ (n âˆˆâ‚™ Ïƒ) 
            {assume h4;
            have H1_0 : Ï€ (n = m)
                {refine eqn_correct n m h4};
            rewrite H1_0;
            refine andâ‚‘â‚ [m âˆˆâ‚™ Ïƒ] [ln âŠ†â‚™ Ïƒ] h2};
        have H2: Ï€ (n âˆˆâ‚™ ln) â†’ Ï€ (n âˆˆâ‚™ Ïƒ)
            {assume h4;
            refine h1 (andâ‚‘â‚‚ [m âˆˆâ‚™ Ïƒ] [ln âŠ†â‚™ Ïƒ] h2) h4};
        refine orâ‚‘ [eqn n m] [n âˆˆâ‚™ ln] (n âˆˆâ‚™ Ïƒ) h3 H1 H2}
end;

opaque symbol preserves_contents_el (n: Ï„ nat) (Ïƒ : ğ•ƒ nat) (l: ğ•ƒ o) : 
    Ï€ (preserves_contents Ïƒ l) â†’  Ï€ (n âˆˆâ‚™ (indexes l)) â†’ Ï€ (n âˆˆâ‚™ Ïƒ) â‰”
begin
    assume n Ïƒ l;
    simplify;
    assume h1 h2;
    refine âŠ†_el n Ïƒ (indexes l) h1 h2;   
end;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// META-THEOREMS ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

opaque symbol permute (Ïƒ : ğ•ƒ nat) (c: ğ•ƒ o) : 
    Ï€ (preserves_contents Ïƒ c) â†’ Ï€(disj c) â†’ Ï€(disj (literals c Ïƒ)) â‰”
begin
    assume Ïƒ c h1 h2;

    have H1: (Î  x: Ï„ nat, Ï€ ((Î» x1, (literal c x1) âˆ§ (x1 âˆˆâ‚™ (indexes c))) x) â†’ Ï€ (`âˆƒ y ,(literal c y) âˆ§ (y âˆˆâ‚™ Ïƒ)))
        {assume x0 h3;
        refine (âˆƒáµ¢ [nat] [Î» y ,(literal c y) âˆ§ (y âˆˆâ‚™ Ïƒ)] x0) (âˆ§áµ¢ (âˆ§â‚‘â‚ h3) (preserves_contents_el x0 Ïƒ c h1 (âˆ§â‚‘â‚‚ h3)))};
    
    have H2: Ï€ (`âˆƒ y ,(literal c y) âˆ§ (y âˆˆâ‚™ Ïƒ))
        {refine âˆƒâ‚‘ (disj_imp_lit c h2) H1};

    refine  lit_imp_disj_pos c Ïƒ H2;
end;

assert l0 l1 l2 âŠ¢ permute (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ l0 â¸¬ â–¡) âŠ¤áµ¢ : Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l0) â†’ Ï€ (l1 âˆ¨ l2 âˆ¨ l0 âˆ¨ l0);

opaque symbol transform [l : Ï„ o] (c: ğ•ƒ o) (n : Ï„ nat) : 
    Ï€ ((literal c n) â‡’ l) â†’ Ï€ (disj c) â†’ Ï€ (disj (set_nth âŠ¥ c n l)) â‰”
begin
    assume l;
    induction
        {simplify;
        assume x h1 h2;
        refine âŠ¥â‚‘ h2}
        {assume x clause h1;
        induction
            {simplify;
            assume h2 h3;
            have H0: Ï€ (x âˆ¨ (disj clause))
                {refine disj_correct x clause h3};
            have H1: Ï€ x â†’ Ï€ (disj (l â¸¬ clause))
                {assume h4;
                refine disj_head l clause (h2 h4)};
            have H2: Ï€ (disj clause) â†’ Ï€ (disj (l â¸¬ clause))
                {assume h4;
                refine disj_tail l clause h4};   
            refine âˆ¨â‚‘ H0 H1 H2}
            {assume n h2 h3 h4;
            have H00: Ï€ (x âˆ¨ (disj clause)) 
                {refine disj_correct x clause h4};
            have H10: Ï€ x â†’ Ï€ (disj (x â¸¬ set_nth âŠ¥ clause n l))
                {assume h5;
                refine disj_head x (set_nth âŠ¥ clause n l) h5};
            have H20:  Ï€ (disj clause) â†’ Ï€ (disj (x â¸¬ set_nth âŠ¥ clause n l))
                {assume h5;
                have H2_0 : Ï€ (disj (set_nth âŠ¥ clause n l))
                    {refine h1 n h3 h5};
                refine disj_tail x (set_nth âŠ¥ clause n l) H2_0};
            refine âˆ¨â‚‘ H00 H10 H20}}
end;
