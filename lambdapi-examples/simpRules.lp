/***************************************************************************
This file provides an axiom and various theorems for propositional equality.        
The theorems are grouped into sections by theme:  
- Symmetry and polarity  
- Various Simplifications                              
****************************************************************************/

require open Stdlib.Set Stdlib.Prop Stdlib.FOL Stdlib.Eq Stdlib.Impred Stdlib.Classic Stdlib.HOL Stdlib.List lambdapi-examples.userDefinedTacticsPrelim;

symbol propExt x y : (Ï€ x â†’ Ï€ y) â†’ (Ï€ y â†’ Ï€ x) â†’ Ï€ (x = y);

symbol funExt [a b] (f g : Ï„ (a â¤³ b)) : Ï€(`âˆ€ x, f x = g x) â†’ Ï€(f = g);


/******************************************************************************
 *  Commutativity, symmetry and polarity                                                     
 ******************************************************************************/

 opaque symbol âˆ¨_com x y:
 Ï€ ((x âˆ¨ y) = (y âˆ¨ x)) â‰”
begin
  assume x y;
  refine propExt (x âˆ¨ y) (y âˆ¨ x) _ _
    {assume h;
    refine âˆ¨â‚‘ h _ _
      {assume h1; refine âˆ¨áµ¢â‚‚ h1}
      {assume h2; refine âˆ¨áµ¢â‚ h2}}
    {assume h;
    refine âˆ¨â‚‘ h _ _
      {assume h1; refine âˆ¨áµ¢â‚‚ h1}
      {assume h2; refine âˆ¨áµ¢â‚ h2}}
end;

opaque symbol âˆ§_com x y:
 Ï€ ((x âˆ§ y) = (y âˆ§ x)) â‰”
begin
  assume x y;
  refine propExt (x âˆ§ y) (y âˆ§ x) _ _
    {assume h; refine âˆ§áµ¢ (âˆ§â‚‘â‚‚ h) (âˆ§â‚‘â‚ h)}
    {assume h; refine âˆ§áµ¢ (âˆ§â‚‘â‚‚ h) (âˆ§â‚‘â‚ h)}
end;

opaque symbol â‡”_com x y:
 Ï€ ((x â‡” y) = (y â‡” x)) â‰”
begin
  assume x y;
  refine propExt (x â‡” y) (y â‡” x) _ _
    {assume h; refine âˆ§áµ¢ (âˆ§â‚‘â‚‚ h) (âˆ§â‚‘â‚ h)}
    {assume h; refine âˆ§áµ¢ (âˆ§â‚‘â‚‚ h) (âˆ§â‚‘â‚ h)}
end;

opaque symbol =_sym [T] (x y : Ï„ T) : 
 Ï€((x = y) = (y = x))â‰”
begin
  assume T x y;
  have H1: Ï€(x = y) â†’ Ï€(y = x)
    {assume h; symmetry; refine h};
  have H2: Ï€(y = x) â†’ Ï€(x = y)
    {assume h; symmetry;refine h};
  refine propExt (x = y) (y = x) H1 H2
end;

opaque symbol polarity_switch x y :
Ï€ ((Â¬ x = Â¬ y) = (x = y)) â‰”
begin
  assume x y;
  refine propExt (Â¬ x = Â¬ y) (x = y) _ _
    {assume h1;
    have H1: Ï€(Â¬ y = Â¬ x)
      {symmetry; refine h1};
    refine propExt x y _ _
      {assume h2;
        have H2: Ï€(Â¬ Â¬ x)
          {assume h3; refine h3 h2};
        refine (Â¬Â¬â‚‘ y) (ind_eq H1 (Î» x, Â¬ x) H2)}
      {assume h2;
        have H2: Ï€(Â¬ (Â¬ y))
          {assume h3; refine h3 h2};
        refine (Â¬Â¬â‚‘ x) (ind_eq h1 (Î» x, Â¬ x) H2)}}
    {assume h1;
    have H1: Ï€(y = x)
      {symmetry; refine h1};
    refine propExt (Â¬ x) (Â¬ y) _ _
      {assume h2; refine ind_eq H1 (Î» x, Â¬ x) h2}
      {assume h2; refine ind_eq h1 (Î» x, Â¬ x) h2}}
end;


/******************************************************************************
 *  Simplifications          
 ******************************************************************************/

// Idempotence and Contradiction for âˆ§ and âˆ¨

opaque symbol âˆ¨_idem x :
  Ï€ ((x âˆ¨ x) = x) â‰”
begin
  assume x;
  refine propExt (x âˆ¨ x) x _ _
    {assume h1;
     refine âˆ¨â‚‘ h1 _ _
       {assume h2; refine h2}
       {assume h2; refine h2}}
    {assume h2; refine âˆ¨áµ¢â‚ h2}
end;

opaque symbol âˆ§_idem x :
  Ï€ ((x âˆ§ x) = x) â‰”
begin
  assume x;
  refine propExt (x âˆ§ x) x _ _
    {assume h1; refine âˆ§â‚‘â‚ h1}
    {assume h1; refine âˆ§áµ¢ h1 h1}
end;

opaque symbol âˆ§_contra_l x :
  Ï€ ((Â¬ x âˆ§ x) = âŠ¥) â‰”
begin
  assume x;
  refine propExt (Â¬ x âˆ§ x) âŠ¥ _ _
    {assume h1;
     refine (âˆ§â‚‘â‚ h1) (âˆ§â‚‘â‚‚ h1)}
     {assume h1; refine âŠ¥â‚‘ h1}
end;

opaque symbol âˆ§_contra_r x :
  Ï€ ((x âˆ§ Â¬ x ) = âŠ¥) â‰”
begin
  assume x; rewrite âˆ§_com; refine âˆ§_contra_l x;
end;


// Disjunction/Conjunction with âŠ¤ / âŠ¥      

opaque symbol âˆ¨âŠ¤ x :
  Ï€ ((x âˆ¨ âŠ¤) = âŠ¤) â‰”
begin
  assume x;
  refine propExt (x âˆ¨ âŠ¤) âŠ¤ _ _
    {assume h1; refine âŠ¤áµ¢}
    {assume h2; refine âˆ¨áµ¢â‚‚ h2}
end;

opaque symbol âŠ¤âˆ¨ x :
  Ï€ ((âŠ¤ âˆ¨ x) = âŠ¤) â‰”
begin
  assume x; rewrite âˆ¨_com; refine âˆ¨âŠ¤ x
end;

opaque symbol âˆ§âŠ¤ x :
  Ï€ ((x âˆ§ âŠ¤) = x) â‰”
begin
  assume x;
  refine propExt (x âˆ§ âŠ¤) x _ _
    {assume h1; refine âˆ§â‚‘â‚ h1}
    {assume h1; refine âˆ§áµ¢ h1 âŠ¤áµ¢}
end;

opaque symbol âŠ¤âˆ§ x :
  Ï€ ((âŠ¤ âˆ§ x) = x) â‰”
begin
  assume x; rewrite âˆ§_com; refine âˆ§âŠ¤ x
end;

opaque symbol âˆ¨âŠ¥ x :
  Ï€ ((x âˆ¨ âŠ¥) = x) â‰”
begin
  assume x;
  refine propExt (x âˆ¨ âŠ¥) x _ _
    {assume h1;
     refine âˆ¨â‚‘ h1 _ _
       {assume h2; refine h2}
       {assume h2; refine âŠ¥â‚‘ h2}}
    {assume h1; refine âˆ¨áµ¢â‚ h1}
end;

opaque symbol âŠ¥âˆ¨ x :
  Ï€ ((âŠ¥ âˆ¨ x) = x) â‰”
begin
  assume x; rewrite âˆ¨_com; refine âˆ¨âŠ¥ x
end;

opaque symbol âˆ§âŠ¥ x :
  Ï€ ((x âˆ§ âŠ¥) = âŠ¥) â‰”
begin
  assume x;
  refine propExt (x âˆ§ âŠ¥) âŠ¥ _ _
    {assume h1; refine âˆ§â‚‘â‚‚ h1}
    {assume h1;
     type âŠ¥â‚‘ h1;
     refine âˆ§áµ¢ (âŠ¥â‚‘ h1) h1}
end;

opaque symbol âŠ¥âˆ§ x :
  Ï€ ((âŠ¥ âˆ§ x) = âŠ¥) â‰”
begin
  assume x; rewrite âˆ§_com; refine âˆ§âŠ¥ x
end;


// Negation of âŠ¤ and âŠ¥  

opaque symbol Â¬âŠ¥ :
  Ï€ (Â¬ âŠ¥ = âŠ¤) â‰”
begin
  refine propExt (Â¬ âŠ¥) âŠ¤ _ _
    {assume h1; refine âŠ¤áµ¢}
    {assume h1 h2; refine h2}
end;

opaque symbol Â¬âŠ¤ :
  Ï€ (Â¬ âŠ¤ = âŠ¥) â‰”
begin
  refine propExt (Â¬ âŠ¤) âŠ¥ _ _
    {assume h1; refine h1 âŠ¤áµ¢}
    {assume h1; refine âŠ¥â‚‘ h1}
end;


// Simplifications on Equalities 

opaque symbol =_idem (t : Set) (x : Ï„ t) : 
  Ï€ ((x = x) = âŠ¤) â‰”
begin
  assume t x;
  refine propExt (x = x) âŠ¤ _ _
    {assume h1; refine âŠ¤áµ¢}
    {assume h1; refine eq_refl x}
end;

opaque symbol Â¬=_idem (t : Set) (x : Ï„ t) :
  Ï€ (Â¬ (x = x) = âŠ¥) â‰”
begin
  assume t x;
  refine propExt (Â¬ (x = x)) âŠ¥ _ _
    {assume h1;
     have xx_ineq: Ï€(x = x) â†’ Ï€ âŠ¥
       {assume h2; refine h1 h2};
     refine xx_ineq (eq_refl x)}
    {assume h1; refine âŠ¥â‚‘ h1}
end;

opaque symbol =âŠ¤ x :
  Ï€ ((x = âŠ¤) = x) â‰”
begin
  assume x;
  refine propExt (x = âŠ¤) x _ _
    {assume h1;
     refine (ind_eq h1 (Î» z, z)) âŠ¤áµ¢}
    {assume h1;
     refine propExt x âŠ¤ _ _
        {assume h2; refine âŠ¤áµ¢}
        {assume h2; refine h1}}
end;

opaque symbol âŠ¤= x :
  Ï€ ((âŠ¤ = x) = x) â‰”
begin
  assume x; rewrite .[x in x = _] (=_sym [o]); refine =âŠ¤ x
end;

opaque symbol Â¬=âŠ¤ x :
  Ï€ (Â¬(x = âŠ¤) = Â¬ x) â‰”
begin
  assume x;
  refine propExt (Â¬(x = âŠ¤)) (Â¬ x) _ _
    {assume h1 h2;
     refine h1 (propExt x âŠ¤ _ _)
        {assume h3; refine âŠ¤áµ¢}
        {assume h3; refine h2}}
    {assume h1 h2;
     have x_true: Ï€ x
       {refine ind_eq h2 (Î» z, z) âŠ¤áµ¢};
     refine h1 x_true}
end;

opaque symbol Â¬âŠ¤= x :
  Ï€ (Â¬(âŠ¤ = x) = Â¬ x) â‰”
begin
  assume x; rewrite .[x in (Â¬ x) = _] (=_sym [o]); refine Â¬=âŠ¤ x
end;

opaque symbol =âŠ¥ x :
  Ï€ ((x = âŠ¥) = Â¬ x) â‰”
begin
  assume x;
  refine propExt (x = âŠ¥) (Â¬ x) _ _
  {assume h1 h2;
   refine (ind_eq (eq_sym h1) (Î» z, z)) h2}
  {assume h2;
   refine propExt x âŠ¥ _ _
   {assume h3; refine h2 h3}
   {assume h3; refine âŠ¥â‚‘ h3}}
end;

opaque symbol âŠ¥= x :
  Ï€ ((âŠ¥ = x) = Â¬ x) â‰”
begin
  assume x; rewrite .[x in x = _] (=_sym [o]); refine  =âŠ¥ x
end;

opaque symbol  Â¬=âŠ¥ x :
  Ï€ (Â¬ (x = âŠ¥) = x) â‰”
begin
  assume x;
  refine propExt (Â¬(x = âŠ¥)) x _ _
  {assume h1;
   refine âˆ¨â‚‘ (em x) _ _
   {assume h2; refine h2}
   {assume h2;
    have eq_x_âŠ¥: Ï€ (x = âŠ¥)
    {refine propExt x âŠ¥ _ _
     {assume h3; refine h2 h3}
     {assume h3; refine âŠ¥â‚‘ h3}};
    have contra: Ï€ âŠ¥
    {refine h1 eq_x_âŠ¥};
    refine âŠ¥â‚‘ contra}}
  {assume h2 eq_x_âŠ¥;
   refine (ind_eq (eq_sym eq_x_âŠ¥) (Î» z, z)) h2}
end;

opaque symbol Â¬âŠ¥= x :
  Ï€ (Â¬ (âŠ¥ = x) = x) â‰”
begin
  assume x; rewrite .[x in (Â¬ x) = _] (=_sym [o]); refine Â¬=âŠ¥ x;
end;


// Simplifications on Equalities with negations

opaque symbol neg=âŠ¤ x :
  Ï€ ((Â¬ x = âŠ¤) = Â¬ x) â‰”
begin
  assume x;
  symmetry;
  refine propExt (Â¬ x) (Â¬ x = âŠ¤) _ _
    {assume h1;
     refine propExt (Â¬ x) âŠ¤ _ _
        {assume h2; refine âŠ¤áµ¢}
        {assume h2; refine h1}}
    {assume h1;
     have H1: Ï€(Â¬ x = âŠ¤) â†’ Ï€(Â¬ x)
       {assume h2;
        refine (ind_eq h2 (Î» z, z)) âŠ¤áµ¢};
     refine H1 h1}
end;

opaque symbol âŠ¤=neg x :
Ï€ ((âŠ¤ = Â¬ x) = Â¬ x) â‰”
begin
  assume x; rewrite .[x in x = _] (=_sym [o]); refine neg=âŠ¤ x
end;

opaque symbol Â¬neg=âŠ¤ x :
  Ï€ (Â¬(Â¬ x = âŠ¤) = x) â‰”
begin
  assume x;
  symmetry;
  refine propExt x (Â¬ (Â¬ x = âŠ¤)) _ _
    {assume h1 h2;
     refine ((ind_eq h2 (Î» z, z)) âŠ¤áµ¢) h1}
    {assume h1;
     refine âˆ¨â‚‘ (em x) _ _
        {assume h2; refine h2}
        {assume h2;
         have H1: Ï€(Â¬ x = âŠ¤)
          {refine propExt (Â¬ x) âŠ¤ _ _
            {assume h3; refine âŠ¤áµ¢}
            {assume h3; refine h2}};
         refine âŠ¥â‚‘ (h1 H1)}}
end;

opaque symbol Â¬âŠ¤neg= x :
  Ï€ (Â¬(âŠ¤ = Â¬ x) = x) â‰”
begin
  assume x; rewrite .[x in Â¬ x = _] (=_sym [o]); refine Â¬neg=âŠ¤ x
end;

opaque symbol neg=âŠ¥ x :
  Ï€ ((Â¬ x = âŠ¥) = x) â‰”
begin
  assume x;
  refine propExt (Â¬ x = âŠ¥) x _ _
    {assume h1;
    refine Â¬Â¬â‚‘ x (ind_eq h1 (Î» y, Â¬ y) (Î» h: Ï€ âŠ¥, h))}
    {assume h1;
     refine propExt (Â¬ x) âŠ¥ _ _
       {assume h2; refine h2 h1}
       {assume h2; refine âŠ¥â‚‘ h2}}
end;

opaque symbol âŠ¥=neg x :
  Ï€ ((âŠ¥ = Â¬ x ) = x) â‰”
begin
  assume x; rewrite .[x in x = _] (=_sym [o]); refine neg=âŠ¥ x
end;

opaque symbol Â¬neg=âŠ¥ x :
  Ï€ (Â¬(Â¬ x = âŠ¥) = Â¬ x) â‰”
begin
  assume x;
  refine ind_eq (polarity_switch (Â¬ x = âŠ¥) x) (Î» z, z) (neg=âŠ¥ x);
end;

opaque symbol Â¬âŠ¥=neg x :
  Ï€ (Â¬(âŠ¥ = Â¬ x) = Â¬ x) â‰”
begin
  assume x; rewrite .[x in Â¬ x = _] (=_sym [o]); refine Â¬neg=âŠ¥ x
end;


// Simplifications on Implication

opaque symbol â‡’_idem x :
  Ï€ ((x â‡’ x) = âŠ¤) â‰”
begin
  assume x;
  refine propExt (x â‡’ x) âŠ¤ _ _
  {assume h1; refine âŠ¤áµ¢}
  {assume h2 y; refine y}
end;

opaque symbol âŠ¤â‡’ x :
  Ï€ ((âŠ¤ â‡’ x) = x) â‰”
begin
  assume x;
  refine propExt (âŠ¤ â‡’ x) x _ _
  {assume h1; refine h1 âŠ¤áµ¢}
  {assume h2 y; refine h2}
end;

opaque symbol â‡’âŠ¤ x :
  Ï€ ((x â‡’ âŠ¤) = âŠ¤) â‰”
begin
  assume x;
  refine propExt (x â‡’ âŠ¤) âŠ¤ _ _
  {assume h1; refine âŠ¤áµ¢}
  {assume h2 y; refine âŠ¤áµ¢}
end;

opaque symbol âŠ¥â‡’ x :
  Ï€ ((âŠ¥ â‡’ x) = âŠ¤) â‰”
begin
  assume x;
  refine propExt (âŠ¥ â‡’ x) âŠ¤ _ _
  {assume h1; refine âŠ¤áµ¢}
  {assume h2 h3; refine âŠ¥â‚‘ h3}
end;

opaque symbol â‡’âŠ¥ x :
  Ï€ ((x â‡’ âŠ¥) = Â¬ x) â‰”
begin
  assume x;
  refine propExt (x â‡’ âŠ¥) (Â¬ x) _ _
  {assume h1 h2; refine h1 h2}
  {assume h2 y; refine h2 y}
end;


// Simplifications on Bi-Implication

opaque symbol â‡”_idem x :
  Ï€ ((x â‡” x) = âŠ¤) â‰”
begin
  assume x;
  refine propExt (x â‡” x) âŠ¤ _ _
  {assume h1; refine âŠ¤áµ¢}
  {assume h2;
   refine âˆ§áµ¢ _ _
   {assume h3; refine h3}
   {assume h3; refine h3}}
end;

opaque symbol â‡”âŠ¤ x :
  Ï€ ((x â‡” âŠ¤) = x) â‰”
begin
  assume x;
  refine propExt (x â‡” âŠ¤) x _ _
  {assume h1;
   refine âˆ§â‚‘â‚‚ h1 âŠ¤áµ¢}
  {assume h2;
   refine âˆ§áµ¢ _ _
   {assume h3; refine âŠ¤áµ¢} 
   {assume h3; refine h2}}
end;

opaque symbol âŠ¤â‡” x :
  Ï€ ((âŠ¤ â‡” x) = x) â‰”
begin
  assume x; rewrite â‡”_com; refine â‡”âŠ¤ x;
end;

opaque symbol â‡”âŠ¥ x :
  Ï€ ((x â‡” âŠ¥) = Â¬ x) â‰”
begin
  assume x;
  refine propExt (x â‡” âŠ¥) (Â¬ x) _ _
  {assume h1;
   refine âˆ§â‚‘â‚ h1}
  {assume h2;
   refine âˆ§áµ¢ _ _
   {assume h3; refine h2 h3}
   {assume h3; refine âŠ¥â‚‘ h3}}
end;

opaque symbol âŠ¥â‡” x :
  Ï€ ((âŠ¥ â‡” x) = Â¬ x) â‰”
begin
  assume x; rewrite â‡”_com; refine â‡”âŠ¥ x;
end;


// Simplifications on Quantifiers

opaque symbol âˆ€_const (t : Set) (p : Ï„ o) : Ï€ ((`âˆ€ (_ : Ï„ t), p) = p)â‰”
begin
    assume t p;
    refine propExt (`âˆ€ x, p) p _ _
        {assume h; refine h (el t)}
        {assume h a; refine h}
end;

opaque symbol âˆƒ_const (t : Set) (p : Ï„ o) : Ï€ ((`âˆƒ (_ : Ï„ t), p) = p)â‰”
begin
    assume t p;
    refine propExt (`âˆƒ x, p) p _ _
        {assume h; 
         have p_holds : Î  (x : Ï„ t), Ï€ p â†’ Ï€ p
          {assume x h2; refine h2};
         refine âˆƒâ‚‘ [t] [Î» y, p] h p_holds}
        {assume h; 
         have p_holds : Ï€ ((Î» x , p) (el t))
          {refine h};
         refine âˆƒáµ¢ [t] [Î» y, p] (el t) p_holds}
end;


// Simplifications reflecting Classical Principles

opaque symbol em_eq_l x :
  Ï€ ((Â¬ x âˆ¨ x) = âŠ¤) â‰”
begin
  assume x;
  refine propExt (Â¬ x âˆ¨ x) âŠ¤ _ _
    {assume h1; refine âŠ¤áµ¢}
    {assume h1;
     have em_sym: Ï€(Â¬ x âˆ¨ x)
       {refine âˆ¨â‚‘ (em x) _ _
         {assume h3; refine âˆ¨áµ¢â‚‚ h3}
         {assume h3; refine âˆ¨áµ¢â‚ h3}};
     refine em_sym}
end;

opaque symbol em_eq_r x :
  Ï€ ((x âˆ¨ Â¬ x) = âŠ¤) â‰”
begin
  assume x; rewrite âˆ¨_com; refine em_eq_l x;
end;

opaque symbol Â¬Â¬â‚‘_eq x :
  Ï€ (Â¬ Â¬ x = x) â‰”
begin
  assume x;
  refine propExt (Â¬ Â¬ x) x _ _
    {assume h1; refine Â¬Â¬â‚‘ x h1}
    {assume h1 h2; refine h2 h1}
end;


/******************************************************************************
  *  Definition of combined Simplification tactic        
  ******************************************************************************/
 
  symbol applyAny : ğ•ƒ tactic â†’ Tactic;
  rule applyAny ($t0 â¸¬ $tl) â†ª $t0 #orelse (applyAny $tl)
  with applyAny â–¡ â†ª #fail;
  
  symbol listOfAllSimpRules â‰” ((#rewrite "" "" âˆ¨_idem) â¸¬ (#rewrite "" "" em_eq_l) â¸¬ (#rewrite "" "" em_eq_r) â¸¬ (#rewrite "" "" âˆ¨âŠ¤) â¸¬ 
      (#rewrite "" "" âŠ¤âˆ¨) â¸¬ (#rewrite "" "" âˆ¨âŠ¥) â¸¬ (#rewrite "" "" âŠ¥âˆ¨) â¸¬ (#rewrite "" "" âˆ§_idem) â¸¬ (#rewrite "" "" âˆ§_contra_r) â¸¬ (#rewrite "" "" âˆ§_contra_l) â¸¬ 
      (#rewrite "" "" âˆ§âŠ¤) â¸¬ (#rewrite "" "" âŠ¤âˆ§) â¸¬ (#rewrite "" "" âˆ§âŠ¥) â¸¬ (#rewrite "" "" âŠ¥âˆ§) â¸¬ (#rewrite "" "" â‡’âŠ¤) â¸¬ (#rewrite "" "" âŠ¥â‡’) â¸¬ (#rewrite "" "" âŠ¤â‡’) â¸¬ 
      (#rewrite "" "" â‡’âŠ¥) â¸¬ (#rewrite "" "" â‡’_idem) â¸¬ (#rewrite "" "" â‡”âŠ¤) â¸¬ (#rewrite "" "" âŠ¤â‡”) â¸¬ (#rewrite "" "" âŠ¥â‡”) â¸¬ (#rewrite "" "" â‡”âŠ¥) â¸¬ 
      (#rewrite "" "" â‡”_idem) â¸¬ (#rewrite "" "" Â¬âŠ¤) â¸¬ (#rewrite "" "" Â¬âŠ¥) â¸¬ (#rewrite "" "" Â¬Â¬â‚‘_eq) â¸¬ (#rewrite "" "" =âŠ¤) â¸¬ (#rewrite "" "" âŠ¤=) â¸¬ 
      (#rewrite "" "" =âŠ¥) â¸¬ (#rewrite "" "" âŠ¥=) â¸¬ (#rewrite "" "" =_idem) â¸¬ (#rewrite "" "" Â¬=âŠ¥) â¸¬ (#rewrite "" "" Â¬âŠ¥=) â¸¬ (#rewrite "" "" Â¬=âŠ¤) â¸¬ 
      (#rewrite "" "" Â¬âŠ¤=) â¸¬ (#rewrite "" "" Â¬=_idem) â¸¬ (#rewrite "" "" âˆ€_const) â¸¬ (#rewrite "" "" âˆƒ_const) â¸¬ (#rewrite "" "" polarity_switch) â¸¬ (#refine "âŠ¤áµ¢") â¸¬ â–¡);
  
symbol applyAllSimplifications â‰” #repeat (applyAny listOfAllSimpRules);