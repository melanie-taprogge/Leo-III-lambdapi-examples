// Necessary standard library encodings
require open Stdlib.Set Stdlib.Prop Stdlib.FOL Stdlib.Epsilon Stdlib.HOL Stdlib.Eq Stdlib.Impred Stdlib.Nat Stdlib.Bool Stdlib.List Stdlib.Classic;

// Encodings derived in the scope of the Leo-III encoding effort
require open lambdapi-examples.simpRules lambdapi-examples.literalLevelOperations lambdapi-examples.userDefinedTacticsPrelim;

/***************************************************************************
 This file documents the encoding of the rules of the EP calculus as presented in:
    Alexander Steen, *Extensional Paramodulation for Higher-Order Logic 
    and its Effective Implementation Leo-III*, Dissertation, Freie 
    UniversitÃ¤t Berlin, 2018. Published in the series *Dissertations in 
    Artificial Intelligence (DISKI)*, Volume 345, ISBN 978-3-89838-739-2.

 The naming conventions and categorization of rules follow those used in
 Steenâ€™s dissertation. The rules are grouped into the following categories:
    â€¢ Unification Rules
    â€¢ Clausification Rules
    â€¢ Extensionality Rules
    â€¢ Primary Inference Rules
    â€¢ Extended Calculus

 For each rule, we provide:

 (1) A discussion of its encoding, which falls into one of the following types:
       (i)  an explicit encoding as an equational or functional theorem in Lambdapi
       (ii) a procedure describing how to encode applications using 
            existing theorems or tactics
       (iii) a justification why no encoding is required

 (2) An indication of whether the rule is implemented in the current Lambdapi 
     output of Leo-III.

 (3) A minimal example illustrating the ruleâ€™s use. The following naming
     conventions are used for each rule R:

       symbol axiom_R_example   â€“ a clause that contains the relevant literal(s)
       symbol proof_R_example   â€“ a proof term that eliminates or transforms them

 Notes: 
     â€¢ Generated proofs often rely on additional implicit transformations and
       performed by the Leo-III implementation (e.g. permutation of clauses, simplifications, ...). 
       These are omitted here but can generally be encoded using additional steps in proofs.
     â€¢ Here we define a new symbol for rule applications that - in the automatically generated
       encodings of longer proofs - would each be defined as a sub-step in longer proofs. This does
       not affect the proofs themselves but only defines the symbols representing the encoded steps
       locally. 
****************************************************************************/

// Declaration of various constants used in the examples:
symbol c : Prop;
symbol d : Prop;

symbol s : Ï„ Î¹;
symbol t : Ï„ Î¹;
symbol u : Ï„ Î¹;
symbol v : Ï„ Î¹;

symbol f : Ï„ (Î¹ â¤³ Î¹);
symbol g : Ï„ (Î¹ â¤³ Î¹);
symbol f_2 : Ï„ (Î¹ â¤³ Î¹ â¤³ Î¹);
symbol g_2 : Ï„ (Î¹ â¤³ Î¹ â¤³ Î¹);

symbol p : Ï„ (Î¹ â¤³ o);
symbol q : Ï„ (Î¹ â¤³ o);


/******************************************************************************
 *  Unification Rules                                                 
 ******************************************************************************/

 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (Triv) 
 // Implemented
 // 
 // Description:
 //    Eliminates literals of the form Â¬(s = s), which are logically equivalent to âŠ¥.
 //    These typically appear as unification constraints after instantiation.
 
 //  Encoding:
 //    In a first step, we prove the implication c âˆ¨ Â¬(s = s) â‡’ c
 //    This is proved via a sequence of simplification steps:
 //      - `Â¬=_idem`    rewrites Â¬(s = s) to âŠ¥
 //      - `âˆ¨âŠ¥` or `âŠ¥âˆ¨` removes âŠ¥ from the disjunction
 //    The resulting implication  c â‡’ c  can be proven via:
 //      - `â‡’_idem`     collapses trivial implications to âŠ¤
 //      - `âŠ¤áµ¢`         completes the proof of the goal
 //    These steps can be applied manually or via the user-defined tactic below:
 symbol Triv â‰” #and (#repeat (#orelse (#and (#rewrite "" "" Â¬=_idem) ((#rewrite "" "" âˆ¨âŠ¥) #orelse (#rewrite "" "" âŠ¥âˆ¨))) (#rewrite "" "" Â¬=_idem))) (#and (#rewrite "" "" â‡’_idem) (#refine "âŠ¤áµ¢"));

 // Example application
 symbol axiom_Triv_example: Ï€ (c âˆ¨ Â¬(s = s));
 symbol proof_Triv_example: Ï€ (c)â‰”
 begin
    // Proof the implication
    have Triv_inst : Ï€ (c âˆ¨ Â¬(s = s) â‡’ c)
        {eval Triv};
    // Use the proven implication to derive the conjecture
    refine Triv_inst axiom_Triv_example
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (Bind)
 // Implemented
 //
 //  Description:
 //    The (Bind) rule handles so-called unification constraints of the form Â¬(X = s),
 //    where X is a free variable and s is a term. These constraints are resolved by
 //    substituting X with s in the remainder of the clause.
 
 //  Encoding:
 //    Applying (Bind) requires the instantiation of the variable X via application and
 //    leads to a literal Â¬(s = s), which is then eliminated using the (Triv) rule.
 //    Thus, (Bind) reduces to two steps:
 //      1. Instantiation of a free variable
 //      2. Elimination of the resulting Â¬(s = s) using the `Triv` tactic
 //
 //  Example:
 symbol axiom_Bind_example: Î  x, Ï€ (p x âˆ¨ Â¬(x = s));
 symbol proof_Bind_example: Ï€ (p s)â‰”
 begin
    // Instantiation of a free variable
    have Axiom_inst: Ï€ (p s âˆ¨ Â¬(s = s))
        {refine axiom_Bind_example s};
    // Elimination of the resulting Â¬(s = s) using the `Triv` tactic
    have Triv_inst : Ï€ ((p s âˆ¨ Â¬(s = s)) â‡’ p s)
        {eval Triv};
    refine Triv_inst Axiom_inst
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (Decomp) 
 // Not implemented
 //  Description:
 //    From an inequality between two applied terms Â¬(f sâ‚€ ... sâ‚™ = f tâ‚€ ... tâ‚™), infer 
 //    that at least one of the arguments differ.

 //  Encoding:
 //    The theorem `Decomp` takes a literal Â¬(f s = g t) and derives that either 
 //    Â¬(f = g) or Â¬(s = t). This allows the use of the theorem for repeated applications,
 //    as it also handles unidentical head symbols. For the final application with identical 
 //    head symbols, the rule derives Â¬(f = f) âˆ¨ Â¬(s = t), the former can be removed using Triv.
 //    The rule is applied using the `transform` theorem.
 symbol Decomp [a b : Set] (s t : Ï„ a) (f g : Ï„(a â¤³ b)): 
    Ï€ (Â¬ (f s = g t)) â†’ Ï€ (Â¬ (s = t) âˆ¨ Â¬ (f = g)) â‰”
 begin
    assume a b s t f g h0;
    refine âˆ¨â‚‘ (em (s = t)) _ _
        {assume h1; refine âˆ¨â‚‘ (em (f = g)) _ _
            {assume h2;
            refine âŠ¥â‚‘ [Â¬ (s = t) âˆ¨ Â¬ (f = g)] (h0 (ind_eq h1 (Î» x, f x = g t) (ind_eq h2 (Î» x, x t = g t) (eq_refl (g t)))))}
            {assume h2; refine âˆ¨áµ¢â‚‚ h2}}
        {assume h1; refine âˆ¨áµ¢â‚ h1}
 end;

 // Example 
 symbol axiom_Decomp_example: Ï€ (c âˆ¨ Â¬((f_2 s t) = (f_2 u v)));
 symbol proof_Decomp_example: Ï€ (c âˆ¨ Â¬(t = v) âˆ¨ Â¬(s = u))â‰”
 begin
    // Repeated application of `Decomp`
    have Decomp_Inst_1 : Ï€ (Â¬ (f_2 s t = f_2 u v)) â†’ Ï€ (Â¬ (t = v) âˆ¨ Â¬ (f_2 s = f_2 u))
        {refine Decomp [Î¹] [Î¹] t v (f_2 s) (f_2 u)};
    have Decomp_App1 : Ï€ (c âˆ¨ Â¬ (t = v) âˆ¨ Â¬ (f_2 s = f_2 u))
        {refine transform [Â¬(t = v) âˆ¨ Â¬ (f_2 s = f_2 u)] (c â¸¬ Â¬((f_2 s t) = (f_2 u v)) â¸¬ â–¡) 1 Decomp_Inst_1 axiom_Decomp_example};
    have Decomp_Inst_2 : Ï€ (Â¬ (f_2 s = f_2 u)) â†’ Ï€ (Â¬ (s = u) âˆ¨ Â¬ (f_2 = f_2))
        {refine Decomp [Î¹] [Î¹ â¤³ Î¹] s u f_2 f_2};
    have Decomp_App_2 : Ï€ (c âˆ¨ Â¬(t = v) âˆ¨ Â¬(s = u) âˆ¨ Â¬(f_2 = f_2))
        {refine transform (c â¸¬  Â¬ (t = v) â¸¬ Â¬(f_2 s = f_2 u) â¸¬ â–¡) 2 Decomp_Inst_2 Decomp_App1};
    // Removal from the Â¬(f_2 = f_2) using `Triv`
    have Triv_inst : Ï€ ((c âˆ¨ Â¬(t = v) âˆ¨ Â¬(s = u) âˆ¨ Â¬(f_2 = f_2)) â‡’ (c âˆ¨ Â¬(t = v) âˆ¨ Â¬(s = u)))
        {eval Triv};
    refine Triv_inst Decomp_App_2
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (FlexRigid) and (FlexFlex)
 // Not implemented
 //
 //  Description:
 //    These rules address unification of a flexible term and - in the case of (FlexRigid) - a 
 //    rigid term or - in the case of (FlexFlex)- a flexible one. They introduce
 //    unification constraints equating the flexible head to a concrete approximation.

 //  Note that as empirical evidence showed that (FlexFlex) can in practice be omitted, it is not 
 //  implemented in Leo-III. It could however be handled exactly like (FlexRigid).
 
 //  Encoding:
 //    No custom theorem is neededâ€”this is handled directly via `âˆ¨áµ¢`.

 // Example 
 symbol axiom_FlexRigid_example: Î  (x : Ï„ (Î¹ â¤³ Î¹)),  Ï€ (c âˆ¨ Â¬(x t = f_2 s t));
 symbol proof_FlexRigid_example: Î  (x : Ï„ (Î¹ â¤³ Î¹)),  Ï€ ((c âˆ¨ Â¬ (x t = f_2 s t)) âˆ¨ (x = f_2 s))â‰”
 begin
    assume x;
    refine âˆ¨áµ¢â‚ [c âˆ¨ Â¬((x t) = (f_2 s t))] [(x = f_2 s)] (axiom_FlexRigid_example x);
 end;


 /******************************************************************************
 *  Clausification Rules                                                 
 ******************************************************************************/

 // â”€â”€â”€â”€â”€â”€â”€ Boolean Equalities Used Implicitly During Clausification
 // Implemented
 //
 //  Description:
 //     During the clausification process, several standard Boolean equivalences
 //     are applied automatically, though they are not listed as explicit rules
 //     in the EP calculus. These include, for instance, conversion of implication 
 //     into disjunction

 //  Encoding:
 //     Equational theorems were encoded covering these rules. They can be found in 
 //     the file `clausificationRules` and can be applied using the `rewrite` tactic.

 require open lambdapi-examples.clausificationRules;

 // Example 
 symbol axiom_CNF_example: Ï€ (c âˆ§ (((p s) âˆ¨ (f s = g s)) â‡’ p u));
 symbol proof_CNF_example: Ï€ (c âˆ§ (Â¬ (p s) âˆ¨ p u) âˆ§ (Â¬ (f s = g s) âˆ¨ p u)) â‰”
 begin
    have RuleApplication : Ï€ ((c âˆ§ (((p s) âˆ¨ (f s = g s)) â‡’ p u)) = (c âˆ§ ((Â¬ (p s) âˆ¨ p u) âˆ§ (Â¬ (f s = g s) âˆ¨ p u))))
        {rewrite â‡’=âˆ¨;
         rewrite deMorgan_âˆ¨;
         rewrite âˆ§âˆ¨_dist_l;
         reflexivity};
    rewrite left RuleApplication;
    refine axiom_CNF_example;
 end; 


 // â”€â”€â”€â”€â”€â”€â”€ (CNFConj)
 // Implemented
 //
 // Description:
 //    This rule selects an individual clause from a conjunction of clauses.

 // Encoding 
 //    The `select` rule handles conjunctions of arbitrary length by working with
 //    sequents and indexed positions. It relies on the same infrastructure as `transform`
 //    and the proof can likewise be found in `literalLevelOperations.lp`

 // Example 
 symbol proof_CNFConj_example: Ï€ (Â¬ (p s) âˆ¨ p u) â‰”
 begin
    refine select 1 (c â¸¬ (Â¬ (p s) âˆ¨ p u) â¸¬ (Â¬ (f s = g s) âˆ¨ p u) â¸¬ â–¡) âŠ¤áµ¢ proof_CNF_example; 
 end;
    

 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (CNFDisj), (CNFNeg), (LiftEq) 
 // Implemented
 //  Description:
 //    â€¢ (CNFDisj): Converts nested disjunctions inside literals to top-level disjunctions of literals\n
 //    â€¢ (CNFNeg):  Removes negation inside a literal and changes the polarity of it
 //    â€¢ (LiftEq):  Lifts literals with equalities to equational literals

 //  Encoding:
 //    No explicit encoding is required in our framework: the chosen representation
 //    of literals in Lambdapi already abstracts away the structural distinctions.
 //    However, as shown in te case of (LiftEq), some cases will require the application of 
 //    boolean identities as the new formation of literals can for instance reorder sides of
 //    equalities or literals in a clause. These instances can be handled by the already 
 //    encoded implicit transformations.

 // Example
 symbol axiom_LiftEq_example: Î  x,  Ï€ (c âˆ¨ (x = s));
 symbol proof_LiftEq_example: Î  x,  Ï€ (c âˆ¨ (s = x))â‰”
 begin
    assume x;
    rewrite =_sym [Î¹];
    refine axiom_LiftEq_example x
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (CNFAll) 
 // Not implemented
 //  Description:
 //    This rule removes universal quantifiers at the outermost level of literals
 //    and replaces them with implicitly quantified variables (Encoded using dependant types).
 
 //  Encoding:
 //     In our encoding, object-level universal quantifiers at the outer scope are by default
 //     identified with dependant types via the rewrite-system. For individual literals, the
 //     rule application thus needs no encoding. When the literal is part of a longer clause,
 //     the quantifiers can be moved to the outer scope step by step using rules like âˆ€âˆ¨_dist_r 
 //     and âˆ€âˆ¨_dist_l. We can then prove in a sub-step that the premise and conclusion - both 
 //     given as universally quantified terms - are equivalent using âˆ€_ext.
 
opaque symbol âˆ€âˆ¨_dist_r t a (p : Ï„(t â¤³ o)): Ï€ ((a âˆ¨ âˆ€ p) = (`âˆ€ x, a âˆ¨ p x))â‰”
begin
    assume t a p;
    refine propExt (a âˆ¨ âˆ€ p) (âˆ€(Î» x, a âˆ¨ p x)) _ _
        {assume h x;
        refine âˆ¨â‚‘ h _ _
            {assume h0;
            refine âˆ¨áµ¢â‚ h0}
            {assume h0;
            refine âˆ¨áµ¢â‚‚ ((=â‡’ (eta_exp_âˆ€ p) h0) x)}}
        {assume h;
        refine âˆ¨â‚‘ (em (âˆ€ p)) _ _
            {assume h1;
            refine âˆ¨áµ¢â‚‚ h1}
            {assume h1;
            have H0: Ï€ (Â¬ (p (Îµ (Î» x, Â¬ (p x)))))
                {refine =â‡’ (âˆ€_skolem t p) h1};
            refine âˆ¨â‚‘ (h (Îµ (Î» x, Â¬ (p x)))) _ _
                {assume h0;
                refine âˆ¨áµ¢â‚ h0}
                {assume h0;
                refine âŠ¥â‚‘ (H0 h0)}}}
end;

opaque symbol âˆ€âˆ¨_dist_l t a (p : Ï„(t â¤³ o)): Ï€ ((âˆ€ p âˆ¨ a) = (`âˆ€ x,p x âˆ¨ a))â‰”
begin
    assume t a p;
    refine propExt (âˆ€ p âˆ¨ a) (`âˆ€ x,p x âˆ¨ a) _ _
        {assume h0 x;
        rewrite âˆ¨_com;
        refine (=â‡’ ((âˆ€âˆ¨_dist_r t a p)) (=â‡’ (âˆ¨_com (âˆ€ p) a) h0)) x}
        {assume h0;
        rewrite âˆ¨_com;
        have H0: Ï€ (`âˆ€ x, a âˆ¨ p x)
            {assume x;
            rewrite âˆ¨_com;
            refine h0 x};
        refine =â‡’ (eq_sym (âˆ€âˆ¨_dist_r t a p)) H0};
end;


opaque symbol âˆ€_ext [t: Set] [p q] : Ï€(`âˆ€ (x : Ï„ t), p x = q x) â†’ Ï€ ((`âˆ€ (x: Ï„ t), p x) = (`âˆ€ (x: Ï„ t), q x))â‰”
begin
    assume t p q h;
    refine propExt (`âˆ€ (x: Ï„ t), p x) (`âˆ€ (x: Ï„ t), q x) _ _
        {assume h1 x;
        refine =â‡’ (h x) (h1 x)}
        {assume h1 x;
        refine =â‡’ (eq_sym (h x)) (h1 x)}
end;


symbol move_âˆ€_out â‰” #repeat ((#rewrite  "" "" âˆ€âˆ¨_dist_r) #orelse (#rewrite "" "" âˆ€âˆ¨_dist_l));

 // Example 
 symbol axiom_CNFAll_example: Ï€ (c âˆ¨ (`âˆ€ x, p x));
 symbol proof_CNFAll_example: Î  y, Ï€ (c âˆ¨ p y)â‰”
 begin
    // substep showing that the axiom is equivalent to the clausfied term
    have CNF_app : Ï€ ((c âˆ¨ (`âˆ€ x, p x)) = (`âˆ€ x, (c âˆ¨ p x)))
        {rewrite âˆ€âˆ¨_dist_r;
        refine âˆ€_ext _;
        assume x; reflexivity};
    refine =â‡’ CNF_app axiom_CNFAll_example;
 end;

 symbol axiom_CNFAll_example_2: Ï€ (c âˆ¨ (`âˆ€ x, p x) âˆ¨ (`âˆ€ x, q x));

 // we can also define a tacitc for easier usage:

 symbol tryVars: ğ•ƒ string â†’ Tactic; 
 rule tryVars ($v0 â¸¬ ($v1 â¸¬ $vs)) â†ª (#assume $v0) #orelse (tryVars ($v1 â¸¬ $vs))
 with tryVars ($v0 â¸¬ â–¡) â†ª (#assume $v0);
 symbol assumeVars (varList: ğ•ƒ string) â‰” (#and (#refine "âˆ€_ext _") (tryVars varList));
 symbol move_âˆ€_out_tac (varList: ğ•ƒ string) â‰” #repeat ((assumeVars varList) #orelse (#and ((#rewrite  "" "" âˆ€âˆ¨_dist_r) #orelse (#rewrite "" "" âˆ€âˆ¨_dist_l)) #simplify_beta));

 symbol proof_CNFAll_example_2: Î  y, Î  z, Ï€ (c âˆ¨ p y âˆ¨ q z)â‰”
 begin
    have Clausification: Ï€ ((c âˆ¨ (`âˆ€ y, p y) âˆ¨ (`âˆ€ z, q z)) = `âˆ€ z, `âˆ€ y, (c âˆ¨ p y âˆ¨ q z))
        {eval move_âˆ€_out_tac ("y" â¸¬ "z" â¸¬ â–¡);
        reflexivity};
        assume y z;
    refine (=â‡’ Clausification axiom_CNFAll_example_2) z y;
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (CNFExist)
 // Implemented
 //
 // Description:
 //    This rule uses skolemisazion to eliminate existential quantifiers.

 // Encoding 
 //     The rule can be proven as an equational theorem (relying on choice)
 //     and can then be applied using the rewrite tactic
 opaque symbol CNFExist (a: Set) (p: Ï„ a â†’ Prop) :  
 Ï€ (Â¬ (âˆ€ p) = Â¬ (p (Îµ (Î» x, Â¬ (p x)))))â‰”
 begin
    assume a p; 
    rewrite Â¬âˆ€=âˆƒÂ¬;
    refine  propExt (`âˆƒ x, Â¬ (p x)) (Â¬ (p (Îµ (Î» x, Â¬ (p x))))) _ _
        {assume h; refine ind_eq (eq_sym (âˆƒ_skolem a (Î» x, Â¬ (p x)))) (Î» x, x) h}
        {assume h; refine ind_eq (âˆƒ_skolem a (Î» x, Â¬ (p x))) (Î» x, x) h}
 end;

 // Example:
 symbol axiom_CNFExist_example: Ï€ (c âˆ¨ Â¬(âˆ€ p));
 // Declare the newly introduced skolem term and define it using the choice operator
 symbol sk1 : Ï„ Î¹;
 symbol sk1_def : Ï€ (sk1 = Îµ (Î» x, Â¬ (p x)));
 symbol proof_CNFExist_example: Ï€ (c âˆ¨ Â¬ (p sk1))â‰”
 begin
    have Skolemisazion : Ï€ (c âˆ¨ Â¬(âˆ€ p) â‡’ c âˆ¨ Â¬ (p sk1))
        {rewrite CNFExist; rewrite sk1_def;
        rewrite â‡’_idem; refine âŠ¤áµ¢};
    refine Skolemisazion axiom_CNFExist_example;
 end;

 // Cases with free variables are handled analogously:
 symbol axiom_CNFExist_example_2: Î  (x : Ï„ Î¹), Ï€ (c âˆ¨ Â¬(âˆ€ (Î» y, x = y)));
 symbol sk2 : Ï„ Î¹;
 symbol sk2_def : Î  z, Ï€ (sk2 = Îµ (Î» (y : Ï„ Î¹), Â¬ (z = y)));
 symbol proof_CNFExist_example_2: Î  (x : Ï„ Î¹),  Ï€ (c âˆ¨ Â¬ ((Î» y, x = y) sk2))â‰”
 begin
    assume x;
    have Skolemisazion : Ï€ ((c âˆ¨ Â¬(âˆ€ (Î» y, x = y))) â‡’ (c âˆ¨ Â¬ ((Î» y, x = y) sk2)))
        {rewrite CNFExist; rewrite (sk2_def x); simplify rule off;
        rewrite â‡’_idem; refine âŠ¤áµ¢};
    refine Skolemisazion (axiom_CNFExist_example_2 x)
 end;


/******************************************************************************
 *  Extensionality Rules                                                 
 ******************************************************************************/

 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (PBE)
 // Implemented
 // 
 // Description:
 //     Derives the mutual implication of two propositions s and t from their
 //     equality (s = t). In Leo-III, this is split into two new clauses, one 
 //     containing the literals Â¬s and t, the other one s and Â¬ t

 // Encoding
 //    Encoded as two functions deriving the two possible resulting clauses. 
 //    This rule can be applied to individual literals via the use of the `transform` theorem.
 opaque symbol PBE_r x y: 
   Ï€(x = y) â†’ Ï€(x âˆ¨ Â¬ y)â‰”
 begin
   assume x y h;
   refine ind_eq h (Î» z, z âˆ¨ Â¬ y) (em y);
 end;

 opaque symbol PBE_l x y: 
    Ï€(x = y) â†’ Ï€(Â¬ x âˆ¨ y)â‰”
 begin
   assume x y h;
   have em_sym: Ï€(Â¬ y âˆ¨ y)
    {refine âˆ¨â‚‘(em y)  _ _ 
       {assume h2;
       refine âˆ¨áµ¢â‚‚ h2}
       {assume h2;
       refine âˆ¨áµ¢â‚ h2}};
   refine ind_eq h (Î» z, Â¬ z âˆ¨ y) em_sym;
 end;

 // Example
 symbol axiom_PBE_example: Î  x,  Ï€ (c âˆ¨ (p s = p x));
 symbol proof_PBE_example: Î  x,  Ï€ (c âˆ¨ Â¬(p s) âˆ¨ (p x))â‰”
 begin
    assume x;
    refine transform (c â¸¬ (p s = p x) â¸¬ â–¡) 1 (PBE_l (p s) (p x)) (axiom_PBE_example x);
 end;

 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (NBE)
 // Implemented
 // 
 // Description:
 //     Analogous to (PBE) for negated qualities between propositions.
 //     This version allows to derive both (s âˆ¨ t) and (Â¬ s âˆ¨ Â¬ t) from
 //     Â¬ (s = t).

 // Encoding 
 opaque symbol NBE_p x y:
    Ï€(Â¬(x = y)) â†’ Ï€(x âˆ¨ y)â‰”
 begin
    assume x y h1;
    refine âˆ¨â‚‘ (em x) _ _
        {assume h2;
        refine âˆ¨áµ¢â‚ h2}
        {assume h2;
        have H1: Ï€ y
            {have H2: Ï€ (Â¬ y) â†’ Ï€ âŠ¥
                {assume h3;
                have H3: Ï€ x â†’ Ï€ y
                    {assume h4;
                    refine âŠ¥â‚‘ (h2 h4)};
                have H4: Ï€ y â†’ Ï€ x
                    {assume h4;
                    refine âŠ¥â‚‘ (h3 h4)};
                refine h1 (propExt x y H3 H4)};
            refine Â¬Â¬â‚‘ y H2};
        refine âˆ¨áµ¢â‚‚ H1};
 end;
 opaque symbol NBE_n x y: Ï€(Â¬(x = y)) â†’ Ï€(Â¬ x âˆ¨ Â¬ y)â‰”
 begin
    assume x y h1;
    refine âˆ¨â‚‘ (em x) _ _
        {assume h2;
        have H1: Ï€ (y) â†’ Ï€ âŠ¥
            {assume h3;
            have H2: Ï€ x â†’ Ï€ y
                {assume h4;
                refine h3};
            have H3: Ï€ y â†’ Ï€ x
                {assume h4;
                refine h2};
            refine h1 (propExt x y H2 H3)};
        refine âˆ¨áµ¢â‚‚ H1}
        {assume h2;
        refine âˆ¨áµ¢â‚ h2}
 end;

 // Example 
 symbol axiom_NBE_example: Î  x,  Ï€ (c âˆ¨ Â¬(p s = p x));
 symbol proof_NBE_example: Î  x,  Ï€ (c âˆ¨ (p s âˆ¨ p x))â‰”
 begin
    assume x;
    refine transform (c â¸¬ Â¬ (p s = p x) â¸¬ â–¡) 1 (NBE_p (p s) (p x)) (axiom_NBE_example x);
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (PFE)
 // Implemented
 // 
 // Description:
 //     Derives the equality of two applied functions (on a fresh variable) 
 //     from the equality of the unapplied functions.

 // Encoding 
 // Encoded as a function that can be applied to individual literals via the
 // `transform` theorem:
 opaque symbol PFE [T] [S] (f g : Ï„ (S â¤³ T)) (x : Ï„ S): 
   Ï€ (f = g) â†’ Ï€ (f x = g x) â‰”
 begin
   assume T S f g x h;
   refine ind_eq h (Î» y, y x = g x) (eq_refl [T] (g x))
 end;

 // Example 
 symbol axiom_PFE_example: Ï€ (c âˆ¨ (f = g));
 symbol proof_PFE_example: Î  x,  Ï€ (c âˆ¨ (f x = g x))â‰”
 begin
    assume x;
    refine transform (c â¸¬ (f = g) â¸¬ â–¡) 1 (PFE f g x) axiom_PFE_example;
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (NFE)
 // Not implemented
 // 
 //  Description:
 //    From the inequality of two functions f and g, derive that there exists an
 //    input on which they differ and instantiate it with a corresponding Skolem term.

 // Encoding
 //     Encoded as an equality and applied via the rewrite tactic.

 // Necessary Lemma
 symbol funExt_neg [a b]  (f g : Ï„(a â¤³ b)) : Ï€ (`âˆƒ x, Â¬ (f x = g x)) â†’ Ï€ (Â¬ (f = g))â‰”
 begin
    assume a b f g h0;
    refine Â¬Â¬â‚‘ (Â¬ (f = g)) _; 
    assume h1;
    have Contra : Ï€ ((`âˆƒ x, Â¬ (f x = g x)) â‡’ âŠ¥)
        {rewrite  Â¬Â¬â‚‘ (f = g) h1;
        assume h2;
        refine âˆƒâ‚‘ h2 _;
        assume x h3;
        refine =â‡’ (Â¬=_idem b (g x)) h3};
    refine Contra h0
 end;

  symbol NFE [a b : Set]  (f g : Ï„(a â¤³ b)) : 
    Ï€ ((Â¬ (f = g)) = (Â¬ (f (Îµ (Î» x, Â¬(f x = g x))) = g (Îµ (Î» x, Â¬(f x = g x))))))â‰”
 begin
    assume a b f g;
    refine propExt (Â¬ (f = g)) (Â¬ (f (Îµ (Î» x, Â¬(f x = g x))) = g (Îµ (Î» x, Â¬(f x = g x))))) _ _
        {assume h0;
        have H0 : Ï€ (`âˆƒ (x: Ï„ a), Â¬ (f x = g x))
        {refine âˆ¨â‚‘ (em (`âˆ€ (x: Ï„ a), (f x = g x))) _ _
            {assume h1;
            refine âŠ¥â‚‘ ( h0 (funExt f g h1))}
            {assume h1;
            refine ind_eq (eq_sym (Â¬âˆ€=âˆƒÂ¬ a (Î» x, f x = g x))) (Î» x, x) h1}};
        refine Îµáµ¢ (Î» x,  Â¬ (f x = g x)) H0}
        {assume h0;
        have H0: Ï€ (`âˆƒ x, Â¬ (f x = g x))
            {refine âˆƒáµ¢ [a] [Î» x , (Â¬ (f x = g x))] (Îµ (Î» x, Â¬ (f x = g x))) h0};
        refine funExt_neg f g H0}
 end;

 // Example
 symbol axiom_NFE_example: Ï€ (c âˆ¨ Â¬(f = g));
 // Declare the newly introduced Skolem term and define it using the choice operator:
 symbol sk3 : Ï„ Î¹;
 symbol sk3_def : Ï€ (sk3 = Îµ (Î» x, Â¬ (f x = g x)));
 symbol proof_NFE_example2: Ï€ (c âˆ¨ Â¬ (f sk3 = g sk3))â‰”
 begin
    rewrite sk3_def;
    rewrite left NFE;
    refine axiom_NFE_example
 end;


/******************************************************************************
 *  Primary Inference Rules                                                 
 ******************************************************************************/

 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (Fac) 
 // Implemented

 //  Description:
 //    This rule implements equal factoring in Leo-III, relying on the introduction
 //    of unification constraints

 // Encoding
 // Encoded in a version for positive literals and one for negative literals. 
 // In case of longer clauses, affected literals must first be moved to the tail end 
 // of the clause (using `permute`), then the rule can be applied via `transform`
 opaque symbol EqFact_p [T : Set] (x y z v : Ï„ T): 
        (Ï€ (x = y âˆ¨ z = v)) â†’ (Ï€ (x = y âˆ¨ Â¬ (x = z) âˆ¨ Â¬ (y = v)))â‰”
 begin
    assume T x y z v h1;
    refine âˆ¨â‚‘ (em (x = y)) _ _ 
                {assume h2;
                refine âˆ¨áµ¢â‚ h2}
                {assume h3;
                refine âˆ¨â‚‘ (em (x = z)) _ _ 
                    {assume h4;
                    refine âˆ¨â‚‘ (em (y = v)) _ _ 
                        {assume h5;
                        have H1: Ï€ (z = v)
                            {refine âˆ¨â‚‘ h1 _ _
                                {assume h6;
                                refine âŠ¥â‚‘ (h3 h6)}
                                {assume h7;
                                refine h7}};
                        have H2: Ï€(x = v)
                            {refine ind_eq h4 (Î» a, a = v) H1};
                        have H3: Ï€(v = y)
                            {refine ind_eq h5 (Î» a, v = a) (eq_refl [T] v)};
                        have H4: Ï€(x = y)
                            {refine ind_eq H2 (Î» a, a = y) H3};
                        refine âŠ¥â‚‘ (h3 H4)}
                        {assume h8;
                        refine âˆ¨áµ¢â‚‚ (âˆ¨áµ¢â‚‚ h8)}}
                    {assume h9;
                    refine âˆ¨áµ¢â‚‚ (âˆ¨áµ¢â‚ h9)}}
 end;
 opaque symbol EqFact_n [T] x y z v: 
        Ï€ (Â¬ (x = y) âˆ¨ Â¬ (z = v)) â†’ Ï€ (Â¬ (x = y) âˆ¨ Â¬ (x = z) âˆ¨ Â¬ (y = v))â‰”
 begin
    assume T x y z v h1;
    refine (âˆ¨â‚‘ (em (x = y)) _ _ )
                {assume h3;
                refine (âˆ¨â‚‘ (em (x = z)) _ _ ) 
                    {assume h4;
                    refine (âˆ¨â‚‘ (em (y = v)) _ _ )
                        {assume h5;
                        have H1: Ï€(z = x)
                            {refine ind_eq h4 (Î» a, z = a) (eq_refl [T] z)};
                        have H2: Ï€(z = y)
                            {refine ind_eq H1 (Î» a, a = y) h3};
                        have H3: Ï€( Â¬ (z = v))
                            {refine âˆ¨â‚‘ h1 _ _
                                {assume h6;
                                refine âŠ¥â‚‘ (h6 h3)}
                                {assume h6;
                                refine h6}};
                        have H4: Ï€(z = v)
                            {refine ind_eq  H2 (Î» a, a = v) h5};
                        refine âŠ¥â‚‘ (H3 H4)}
                        {assume h6;
                        refine âˆ¨áµ¢â‚‚ (âˆ¨áµ¢â‚‚ h6)}}
                    {assume h4;
                    refine âˆ¨áµ¢â‚‚ (âˆ¨áµ¢â‚  h4)}}
                {assume h3;
                refine âˆ¨áµ¢â‚ h3}
 end;

 // Example
 symbol axiom_EqFact_example: Î  x,  Ï€ (c âˆ¨ (f_2 s = f_2 x) âˆ¨ (f_2 t = g));
 symbol proof_EqFact_example: Î  x,  Ï€ (c âˆ¨ (f_2 s = f_2 x) âˆ¨ (Â¬ (f_2 s = f_2 t) âˆ¨ Â¬ (f_2 x = g)))â‰”
 begin
   assume x;
   refine transform (c â¸¬ ((f_2 s = f_2 x) âˆ¨ (f_2 t = g)) â¸¬ â–¡) 1 (EqFact_p (f_2 s) (f_2 x) (f_2 t) g) (axiom_EqFact_example x);
 end;


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (Para)
 // Implemented
 //
 // Description:
 //   Paramodulation performs a conditional rewrite of a subterm using an
 //   equational literal from another clause. Given two clauses:
 //     â€¢ one containing an equality literal (l = r)
 //     â€¢ another containing a literal (s = t), where some subterm s|_pos unifies with l
 //   we derive a clause where:
 //     â€¢ the subterm s|_pos is rewritten to r at position pos
 //     â€¢ the unification constraint Â¬(s|_pos = l) (UF) is added
 //     â€¢ the remaining literals from both clauses are preserved
 //
 // Encoding:
 //   Implemented case-by-case via concrete rewrite steps, instantiations, and
 //   disjunction handling (âˆ¨-intro/elims). The general procedure:
 //     â€¢ Case split on UF:
 //       A) UF holds: perform the targeted rewrite. If the with-clause has multiple 
 //          literals, use âˆ¨-elimination to access the equational branch.
 //          Finish by re-introducing the into-clause disjuncts via âˆ¨ introdcution.
 //       B) Â¬UF holds: close via âˆ¨ introdcution based on the the negated constraint.
 //
 //   No dedicated Lambdapi rule is required, we do however rely on literal-level transformation
 //   theorems (n-ary âˆ¨-introduction) from "multiND.lp".
 require open lambdapi-examples.multiND;


 // Excluded middle for the UF of this example
 symbol axiom_0_Para_example: Î  x, Ï€ ((p x âˆ¨ p t) = (s = t));
 symbol axiom_1_Para_example: Ï€ (p s = p t);
 symbol proof_Para_example: Î  x, Ï€ (((p t âˆ¨ p t) = (s = t)) âˆ¨  Â¬(p x = p s))â‰”
 begin
    assume x;
    // Case split on UF: (p x = p s) âˆ¨ Â¬(p x = p s)
    refine âˆ¨â‚‘ (em  (p x = p s)) _ _
        {// Case A: UF is TRUE
        assume UF;

        // rewriting with both equalities will render the first literal equal to `axiom_0_Para_example`
        rewrite left .[x in ((x âˆ¨ _) = _) âˆ¨ _] axiom_1_Para_example;
        rewrite left .[x in ((x âˆ¨ _) = _) âˆ¨ _] UF;

        // refine using âˆ¨ introduction:
        refine âˆ¨áµ¢â‚ (axiom_0_Para_example x)}

        {// Case B: UF is FALSE
        assume nUF;
        // Close by introducing the left disjunct Â¬UF
        refine âˆ¨áµ¢â‚‚ nUF}
end;


 //  Example (with additional literals):
 symbol axiom_0_Para_example_2: Î  x, Ï€ (c âˆ¨ ((p x âˆ¨ p t) = (s = t)));
 symbol axiom_1_Para_example_2: Ï€ (d âˆ¨ (p s = p t));
 symbol proof_Para_example_2: Î  x, Ï€ (c âˆ¨ ((p t âˆ¨ p t) = (s = t)) âˆ¨ d âˆ¨ Â¬(p x = p s))â‰”
 begin
    assume x;
    // Case split on UF: (p x = p s) âˆ¨ Â¬(p x = p s)
    refine âˆ¨â‚‘ (em (p x = p s)) _ _
        {// Case A: UF is TRUE
        assume UF;
        // Case split on clause axiom_1_Para_example_2
        refine âˆ¨â‚‘ axiom_1_Para_example_2 _ _
            {// Case A: the rest of example clause holds
            assume restClause;
            // we can thus refine using âˆ¨-indtoruction
            refine (âˆ¨áµ¢â‚™â‚‚ (c â¸¬ ((p t âˆ¨ p t) = (s = t))  â¸¬ â–¡) (d â¸¬ Â¬ (p x = p s) â¸¬ â–¡) (âˆ¨áµ¢â‚ restClause))}

            // Case B: Equational literal of example clause holds
            {assume EL;
            // rewriting with both equalities will render the first half of the clause equal to `axiom_0_Para_example`
            rewrite left .[x in (_ âˆ¨ (((x âˆ¨ _) = _) âˆ¨ _ âˆ¨ _))] EL;
            rewrite left .[x in (_ âˆ¨ (((x âˆ¨ _) = _) âˆ¨ _ âˆ¨ _))] UF;
            // we can thus refine using âˆ¨-indtoruction
            refine âˆ¨áµ¢â‚™â‚ (c â¸¬ (((p x âˆ¨ p t) = (s = t))) â¸¬ â–¡) (d â¸¬ Â¬ (p x = p s) â¸¬ â–¡) (axiom_0_Para_example_2 x)}}

        {// Case B: UF is FALSE
        assume nUF;
        // Close by introducing the left disjunct Â¬UF
        refine âˆ¨áµ¢â‚™â‚‚ (c â¸¬ (((p t âˆ¨ p t) = (s = t))) â¸¬ d â¸¬ â–¡) (Â¬ (p x = p s) â¸¬ â–¡) nUF}
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (Prim)
 // Not implemented
 // 
 // Description:
 //     This rule introduces a binding to approximate the structure of a literal
 //     with a flexible head. The instantiation is added as a unification-constraint.

 // Encoding:
 //     Like (FlexRigid), this rule can be verified as an instance of âˆ¨áµ¢â‚ and no
 //     new theorem is necessary.

 // Example:
 symbol axiom_Prim_example: Î  (x : Ï„ (Î¹ â¤³ Î¹ â¤³ o)),  Ï€ (c âˆ¨ Â¬(x t s));
 symbol proof_Prim_example: Î  (x : Ï„ (Î¹ â¤³ Î¹ â¤³ o)),  Ï€ ((c âˆ¨ Â¬(x t s)) âˆ¨ (x = (=) [Î¹]))â‰”
 begin
    assume x;
    refine âˆ¨áµ¢â‚ [c âˆ¨ Â¬(x t s)] [x = (=) [Î¹]] (axiom_Prim_example x);
 end;


/******************************************************************************
 *  Extended Calculus                                               
 ******************************************************************************/

 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (RW) 
 // Implemented
 //
 // Description:
 //     Given a clause consisting only of an equational literal (s = t), use it
 //     to rewrite a subterm in another clause.
 
 // Encoding:
 //     No additional encoding is necessary as this can be handled directly using 
 //     the standard `rewrite` tactic.
 
 // Example:
 symbol axiom_0_RW_example: Ï€ (c âˆ¨ p s);
 symbol axiom_1_RW_example: Î  x,  Ï€ (p x = âŠ¤);
 symbol proof_RW_example: Ï€ (c âˆ¨ âŠ¤)â‰”
 begin
    rewrite left (axiom_1_RW_example s);
    refine axiom_0_RW_example
 end;

 
 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (DD)
 // Implemented
 //
 // Description:
 //     Justifies the removal of duplicate literals within a single clause.
 
 // Encoding:
 //    Encoded as the rule `delete`, which relies on the same infrastructure
 //    as `transform` and the proof can likewise be found in `literalLevelOperations.lp`
 
 // Example:
 symbol axiom_DD_example: Î  x,  Ï€ (c âˆ¨ p x âˆ¨ p x);
 symbol proof_DD_example: Î  x,  Ï€ (c âˆ¨ p x)â‰”
 begin
   assume x;
   refine delete (0 â¸¬ 1 â¸¬ 1 â¸¬ â–¡) (0 â¸¬ 1 â¸¬ â–¡) (c â¸¬ (p x) â¸¬ (p x) â¸¬ â–¡) âŠ¤áµ¢ (axiom_DD_example x);
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (Simp)
 // Implemented
 //
 // Description:
 //     Exhaustively applies Boolean identities (such as (x âˆ¨ x) = x) as simplifications.
 //
 // Encoding:
 //     The encoding consists of a total of  of 40 proven Boolean equalities, located in
 //     `simpRules.lp`. These are bundled into a Lambdapi tactic (`applyAllSimplifications`) 
 //     that applies all of them exhaustively using repeated `rewrite` applications.
 //
 // Example:
 symbol axiom_Simp_example: Î  x,  Ï€ (Â¬ ((c â‡’ (c âˆ¨ âŠ¥)) âˆ¨ (p x âˆ¨ p x) = âŠ¤));
 symbol proof_Simp_example: Ï€ âŠ¥ â‰”
 begin
   have SimpApp : Ï€ (Â¬ ((c â‡’ (c âˆ¨ âŠ¥)) âˆ¨ (p (el Î¹) âˆ¨ p (el Î¹)) = âŠ¤) â‡’ âŠ¥)
      {eval applyAllSimplifications};
   refine SimpApp (axiom_Simp_example (el Î¹))
 end;
print funExt;

 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (TD1), (TD2), (CS), (ACD) 
 //     These rules are used internally by the prover to remove clauses from the
 //     search space. Since they do not contribute to the derivation of the final conclusion,
 //     they are never explicitly referenced in proof certificates and need not be encoded.


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (HeuInst)
 // Not implemented
 //
 // Description:
 //     This rule heuristically instantiates universally quantified variables in a
 //     formula. 

 // Encoding:
 //     In Lambdapi, heuristic instantiation is achieved simply by function application 
 //     to the quantified (sub-)term. In some cases, the formula may need to be instantiated inside
 //     nested structures. For this, additional structural lemmas (e.g., for conjunction) that can 
 //     be encoded as equational theorems. Here we give one example for such a rule:
 symbol nestedApp_âˆ§_l x y z : Ï€ (x â‡’ z) â†’ Ï€ (x âˆ§ y) â†’ Ï€ (z âˆ§ y)â‰”
 begin
    assume x y z h0 h1;
    refine âˆ§áµ¢ (h0 (âˆ§â‚‘â‚ h1)) (âˆ§â‚‘â‚‚ h1)
 end;

 // Example (direct instantiation):
 symbol axiom_HeuInst_example_1: Ï€ (c âˆ¨ `âˆ€ x, x = (x âˆ¨ x));
 symbol proof_HeuInst_example_1: Ï€ (c âˆ¨ âŠ¤ = (âŠ¤ âˆ¨ âŠ¤))â‰”
 begin
     have Inst : Ï€ ((`âˆ€ x, x = (x âˆ¨ x)) â‡’ (âŠ¤ = (âŠ¤ âˆ¨ âŠ¤)))
         {assume h;
         refine h âŠ¤};
     refine transform (c â¸¬ (`âˆ€ x, x = (x âˆ¨ x)) â¸¬ â–¡) 1 Inst axiom_HeuInst_example_1
 end;

 // Example (nested instantiation inside a conjunction):
 symbol axiom_HeuInst_example_2: Ï€ (c âˆ¨ ((`âˆ€ x, x = (x âˆ¨ x)) âˆ§ c));
 symbol proof_HeuInst_example_2: Ï€ (c âˆ¨ (âŠ¤ = (âŠ¤ âˆ¨ âŠ¤) âˆ§ c))â‰”
 begin
    have Inst : Ï€ ((`âˆ€ x, x = (x âˆ¨ x)) â‡’ (âŠ¤ = (âŠ¤ âˆ¨ âŠ¤)))
         {assume h;
         refine h âŠ¤};
    have NestedAppliation : Ï€ (((`âˆ€ x, x = (x âˆ¨ x)) âˆ§ c) â‡’ ((âŠ¤ = (âŠ¤ âˆ¨ âŠ¤)) âˆ§ c))
        {refine nestedApp_âˆ§_l (`âˆ€ x, x = (x âˆ¨ x)) c (âŠ¤ = (âŠ¤ âˆ¨ âŠ¤)) Inst};
    refine transform (c â¸¬ ((`âˆ€ x, x = (x âˆ¨ x)) âˆ§ c) â¸¬ â–¡) 1 NestedAppliation axiom_HeuInst_example_2
 end;



 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (PSR), (NSR)
 // Not implemented
 //
 // Description:
 //     These rules allow us to remove equality literals from clauses when they contradict
 //     an already established equality in the proof:
 //     â€¢ (PSR) â€“ Positive Superposition Resolution:
 //         From two clauses:  c âˆ¨ Â¬(s = t)       and      l = r
 //         If:                there exists Ïƒ such that Ïƒ(l = r) = (s = t)
 //         Then:              derive c
 //     â€¢ (NSR) â€“ Negative Superposition Resolution:
 //         Analogous, but applies to positive equality literals and matching negative ones.

 // Encoding (PSR):
 //     No standalone theorem is required. In the encoding we can simply define a substep
 //     that proves the remaining clause `c` from the clause `c âˆ¨ Â¬(s = t)` by using the
 //     rewrite tactic with the instanciated unit-clause `l = r` and then deleting the resulting
 //     trivially false equational literal using the procedure defined for (Triv).

 symbol PSR_simp [p : Prop] (rwEq : Ï€ (p = âŠ¤)) â‰” #and (#and (#and (#rewrite "" "" rwEq) (#rewrite "" ""  Â¬âŠ¤)) 
                   ((#rewrite "" ""  âˆ¨âŠ¥) #orelse (#rewrite "" "" âŠ¥âˆ¨))) (#and (#rewrite "" "" â‡’_idem) (#refine "âŠ¤áµ¢"));

 // Example
 symbol axiom_0_PSR_example_2: Î  y ,Ï€ (c âˆ¨ Â¬(f t = f_2 t y));
 symbol axiom_1_PSR_example_2: Î  x y, Ï€ ((f x = f_2 t y));
 symbol proof_PSR_example_2: Ï€ c â‰”
 begin
    have TrivApp : Ï€ (((c âˆ¨ Â¬(f t = f_2 t (el Î¹)))) â‡’ c)
        {rewrite axiom_1_PSR_example_2 t (el Î¹);
        eval Triv};
    refine TrivApp (axiom_0_PSR_example_2 (el Î¹))
 end;
 // Note:
 //    We use the placeholder constant `el` to denote an arbitrary representative of a given type, 
 //    to instantiate variables disappearing from the clause as a result of the rule application as needed. 
 //    This is justified by the occupation of types in HOL.

 // NSR is handled similarly, but here we have to do a case-split on the literals of the clause `c âˆ¨ (f t = f_2 t y)`
 // In the first case we reason under the assumtion of `c`, which can simply be used to instanciate the goal. 
 // In the second case we assume `(f t = f_2 t y)`, this can be used with the rewrite tactic to derive a contradition
 // with `(Â¬(f x = f_2 t y))`:
 symbol axiom_0_NSR_example_2: Î  y ,Ï€ (c âˆ¨ (f t = f_2 t y));
 symbol axiom_1_NSR_example_2: Î  x y, Ï€ (Â¬(f x = f_2 t y));
 symbol proof_NSR_example_2: Ï€ c â‰”
 begin
    refine âˆ¨â‚‘ (axiom_0_NSR_example_2 (el Î¹)) _ _
        {assume piC; refine piC}
        {assume eqLit; 
        have TrivApp : Ï€ (Â¬(f t = f_2 t (el Î¹)) â‡’ âŠ¥)
            {rewrite eqLit ;
            eval Triv};
        refine âŠ¥â‚‘ (TrivApp (axiom_1_NSR_example_2 t (el Î¹)))};
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (LEQ)
 // Not implemented
 //
 // Description:
 //     Replaces user-defined Leibniz equalities with standard equality.
 //
 //     In the clausified form, a Leibniz equality defined as:
 //         Î» x. Î» y. `âˆ€ p, p x â‡’ p y
 //     results in two literals: Â¬(p x) and (p y), with the universally quantified predicate p.
 //     Leo-III handles this by instantiating p with (Î» x, s = x).
 //
 // Encoding:
 //     The instantiation is performed directly via application.
 //     The resulting clause can then be simplified using the encoding of (Triv):

 // Example
 symbol axiom_LEQ_example: Î  (q : Ï„(Î¹ â¤³ o)) , Ï€ (c âˆ¨ Â¬(q s) âˆ¨ (q t));
 symbol proof_LEQ_example: Ï€ (c âˆ¨ (s = t))â‰”
 begin
    type axiom_LEQ_example (Î» x, s = x);
    compute Ï€ (c âˆ¨ (Â¬ ((Î» x, s = x) s) âˆ¨ (Î» x, s = x) t));
    have Substitution: Ï€ (c âˆ¨ (Â¬ (s = s)) âˆ¨ (s = t))
        {refine axiom_LEQ_example (Î» x, s = x)};
    have TrivApp: Ï€ ((c âˆ¨ (Â¬ (s = s)) âˆ¨ (s = t)) â‡’ (c âˆ¨ (s = t)))
        {eval Triv};
    refine TrivApp Substitution
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (AEQ)
 // Not implemented
 //
 // Description:
 //     Replaces user-defined Andrews equality with standard equality.
 //
 //     Andrews equality is defined as:
 //         Î» x. Î» y. `âˆ€ r, âˆ€ z, r z z â‡’ r x y
 //
 //     In clausified form, it may appear as a unification constraint Â¬(r s s),
 //     with an implicitly quantified p. Leo-III handles this by instantiating p with (=).
 //
 // Encoding:
 //     Instantiation is done via application. The resulting clause simplifies the procedure introduced in (Triv):
 symbol AEQ [a : Set] x (s : Ï„ a): Ï€ (x âˆ¨ Â¬ (s = s) â‡’ x)â‰”
 begin
    assume a z s;
        rewrite Â¬=_idem;
        rewrite âˆ¨âŠ¥;
        assume h; refine h
 end;
       
 // Example 
 symbol axiom_AEQ_example: Î  (p : Ï„(Î¹ â¤³ Î¹ â¤³ o)) , Ï€ ((`âˆ€ x, p x s â‡’ q x) âˆ¨ Â¬(p s s));
 symbol proof_AEQ_example: Ï€ (`âˆ€ x, x = s â‡’ q x)â‰”
 begin
    have Substitution : Ï€ ((`âˆ€ x, (x = s) â‡’ q x) âˆ¨ Â¬ (s = s))
        {refine  axiom_AEQ_example (=)};
    have TrivApp : Ï€ (((`âˆ€ x, (x = s) â‡’ q x) âˆ¨ Â¬ (s = s)) â‡’ (`âˆ€ x, x = s â‡’ q x))
        {eval Triv};
    refine TrivApp Substitution
 end;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (ACI)
 // Not implemented
 //
 // Description:
 //     Instantiates the axiom of choice by introducing a choice term Îµ f
 //     for a predicate f.  

 // Encoding:
 //     This rule is encoded as a Lambdapi theorem, which can be instantiated 
 //     with any predicate:
 symbol ACI [a: Set] (f: (Ï„ a â†’ Prop)) : Î  (x : Ï„ a), Ï€ (Â¬ (f x) âˆ¨ (f (Îµ f)))â‰”
 begin
    assume a f x;
    rewrite left â‡’=âˆ¨;
    assume h0;
    refine Îµáµ¢ f (âˆƒáµ¢ [a] [f] x h0)
 end;

 // Example
 symbol ACI_example : Î  x: Ï„ Î¹, Ï€ (Â¬ (p x) âˆ¨ p (Îµ p)) â‰” ACI p;


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (INJ)
 // Not implemented
 //
 // Description:
 //     This rule scans for instances of injective functions and proves the existence of
 //     inverse functions for them.
 //
 // Encoding:
 //     We prove the rule as a function that proves the existence of an inverse. We can then 
 //     proceed as in the verification of skolemisazion steps to proof the application
 //     of the inference rule based on the proof of the existence given by our encoding of (INJ).

symbol INJ [a b: Set] (f : Ï„ (a â¤³ b)) : Ï€ (`âˆ€ x, `âˆ€ y, (Â¬ (f x = f y) âˆ¨ (x = y))) â†’ Ï€ (`âˆƒ (f_in : Ï„ (b â¤³ a)), `âˆ€ x, f_in (f x) = x)â‰”
 begin
    assume a b f h0;
    refine Â¬Â¬â‚‘ (`âˆƒ (f_in : Ï„ (b â¤³ a)), `âˆ€ x, f_in (f x) = x) _;
    assume negConj;
    have H0: Ï€ (`âˆ€ (f_in : Ï„ (b â¤³ a)), Â¬ (`âˆ€ x0, f_in (f x0) = x0))
        {refine Â¬âˆƒ (Î» (f_in : Ï„ (b â¤³ a)), `âˆ€ x, f_in (f x) = x) negConj};
    have H1: Ï€ (`âˆ€ (f_in : Ï„ (b â¤³ a)), (`âˆƒ x0, Â¬ (f_in (f x0) = x0)))
        {assume f_in;
        refine =â‡’ (Â¬âˆ€=âˆƒÂ¬ a (Î» x, (f_in (f x) = x))) _;
        refine H0 f_in};
    set f_invv â‰”  Î» (y : Ï„ b), Îµ (Î» (x: Ï„ a), f x = y);
    refine âˆƒâ‚‘ (H1 f_invv) _;
    assume x h1;
    refine âˆ¨â‚‘ (h0 x (f_invv (f x))) _ _
        {assume h2; 
        have H2 :  Ï€ (f x = f (f_invv (f x)))
            {symmetry;
            type Îµáµ¢ [a] (Î» (z: Ï„ a), f z = f x);
            refine Îµáµ¢ [a] (Î» (z: Ï„ a), f z = f x) _;
            refine âˆƒáµ¢ x _;
            reflexivity};
        refine h2 H2}
        {assume h2;
        refine h1 (eq_sym h2)};
 end;

symbol axiom_INJ_example x y: Ï€ (Â¬ (f x = f y) âˆ¨ (x = y));
symbol sk4 : Ï„ (Î¹ â¤³ Î¹);
symbol sk4_def : Ï€ (sk4 = (Îµ (Î» f_in, `âˆ€ x1, f_in (f x1) = x1)));
 symbol proof_INJ_example x: Ï€ ((sk4 (f x)) = x) â‰”
 begin
    assume x;
    rewrite sk4_def;
    refine Îµáµ¢ [Î¹ â¤³ Î¹] ((Î» f_in, `âˆ€ x0, f_in (f x0) = x0)) (INJ [Î¹] [Î¹] f axiom_INJ_example) x;
 end;

 // cases with multiple arguments are more complicated and may require permuting the arguments first:

 symbol axiom_INJ_example_2 x y z: Ï€ (Â¬ (f_2 x z = f_2 y z) âˆ¨ (x = y));
 symbol sk5 : Ï„ (Î¹ â¤³ Î¹ â¤³ Î¹);
 symbol sk5_def z : Ï€ (sk5 = (Îµ (Î» (f_inv : Ï„ (Î¹ â¤³ Î¹ â¤³ Î¹)), `âˆ€ (x : Ï„ Î¹), (f_inv z (f_2 x z)) = x)));
 symbol proof_INJ_example_2 x z: Ï€ ((sk5 z (f_2 x z)) = x) â‰”
 begin
    have proofForPermutedArgs : Î  z, Ï€ (`âˆƒ (f_inv : Ï„ (Î¹ â¤³ Î¹ â¤³ Î¹)), `âˆ€ (x : Ï„ Î¹), (f_inv z (f_2 x z)) = x)
        {assume z;
        set f_2'' â‰” Î» x, Î» y, f_2 y x;

    have changedPos' : Î  (x : Ï„ Î¹), Î  (y : Ï„ Î¹),  Ï€ (Â¬ (f_2'' z x = f_2'' z y) âˆ¨ (x = y))
        {assume x y;
        simplify;
        refine axiom_INJ_example_2 x y z};
    have H00: Ï€ (`âˆƒ (f_inv : Ï„ (Î¹ â¤³ Î¹)), `âˆ€ x, f_inv (f_2'' z x) = x) 
        {refine INJ (f_2'' z) changedPos'};
    refine âˆƒâ‚‘ H00 _;
    assume f_inv0 h0;
    set f_inv â‰” Î» (x : Ï„ Î¹), f_inv0;
    refine âˆƒáµ¢ f_inv _;
    refine h0};
    assume x z;
    rewrite sk5_def z;
    refine Îµáµ¢ [Î¹ â¤³ Î¹ â¤³ Î¹] (Î» f_inv, `âˆ€ x, f_inv z (f_2 x z) = x) (proofForPermutedArgs z) x;
 end;


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (FS)

 //  Description:
 //    Function synthesis from negative equational constraints.
 //    Leo-III scans for clauses that contain constraints of the form
 //      Â¬(F s^{k,1} â€¦ s^{k,n} = t^k)   (k = 1..m),
 //    i.e., the clause â€œspecifiesâ€ the values that F should take on the listed
 //    arguments. (FS) instanciates F by a Î»-term defined via choice that satisfies
 //    all these specifications.

 //  Encoding:
 //    We instantiate the clause with the synthesized function
 //      F := Î» X^1 â€¦ X^n. Îµ Z.\, âˆ§_{k=1}^m ( (âˆ§_{j=1}^n X^j = s^{k,j}) â†’ Z = t^k )

 // Example:
 symbol axiom_FS_example :
        Î  (F : Ï„(Î¹ â¤³ Î¹)), Ï€ ((F s = v) âˆ¨ Â¬(F s = t) âˆ¨ Â¬(F u = v));

 // for readiablility, we define the intorduced unification constraint here:
 symbol F_inst : Ï„ (Î¹ â¤³ Î¹) â‰”
        Î» x, Îµ (Î» z, ((x = s) â‡’ z = t) âˆ§ ((x = u) â‡’ z = v));

 symbol proof_FS_example :
        Ï€ ((F_inst s = v) âˆ¨ Â¬(F_inst s = t) âˆ¨ Â¬(F_inst u = v))â‰”
    begin
        refine axiom_FS_example F_inst
    end;
