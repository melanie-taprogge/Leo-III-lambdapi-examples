/* Library on Meta-Theorems for Disjunctions

-------------------

Note that this file has been added to the standard library. 
It has been included here for the sake of self-containment.

The library proves the following meta-theorems:

** n-ary Natural Deduction rules:
   - âˆ¨áµ¢â‚™ is the n-ary versions of the introduction rule for âˆ¨.
   - âˆ¨â‚‘â‚™ is the n-ary version of the elimination rule for âˆ¨.

** Permute:
   The theorem is instantiated with:
   - A list of natural numbers representing a permutation.
   - A list of terms of type `o` representing a clause.

   The theorem verifies that the permuted clause still contains all literals of the original clause. 
   If so, it maps the disjunction of the original clause to the disjunction after the permutation.

** Delete:
   The theorem is instantiated with three lists:
   1. A list of natural numbers representing the indices of literals in the original clause. 
     For literals occurring multiple times, the index of the first occurrence is used for all of the
     subsequent occurrences. For example, for `Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1)`, this list would be `(0, 1, 2, 1)`.
   2. A second list of natural numbers indicating the desired positions of the literals in the resulting clause.
     If for instance the second occurrence of `l1` in `Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1)` should be deleted, the 
     derived clause would be `Ï€ (l0 âˆ¨ l1 âˆ¨ l2)`, and the list that must be provided would be (0, 1, 2).
     To delete the first occurrence of `l1`, and derive the clause `Ï€ (l0 âˆ¨ l2 âˆ¨ l1)`, the list would 
     be (0, 2, 1).
   3. A list of terms of type `o`, representing literals.

   The resulting theorem verifies if each literal from the original clause is still present at least once 
   in the derived clause. If so, it maps the disjunction of the original literals to the disjunction after 
   the desired double literal deletion. This approach allows multiple identical literals to be deleted at once.

** DeleteDoubles:
   A convenience version of Delete, where duplicate occurrences of literals are removed automatically,
   leaving only the first occurrence.

   The theorem is instantiated with:
   - A list of natural numbers representing the indices of literals in the original clause. As in Delete,
     when a literal occurs multiple times, all occurrences are represented using the index of its first occurrence.
   - A list of terms of type `o`, representing literals.

   The theorem maps the original clause directly to a version where all duplicate literals have been removed.

** Transform:
   This theorem is useful when a rule is applied to only one literal of a clause. 
   For example, consider the clause `Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l3)` and an inference rule `Ï€ l2 â†’ Ï€ l2'`. 
   The transformation theorem can be instantiated with:
   - The list of terms of type `o` representing the original clause.
   - The position of the literal being affected.
   - The inference rule.

   The resulting term maps the original disjunction to one with the transformed literal.

---

** General Concept:
   The general idea behind the permutation and double literal deletion theorems is to evaluate a list of natural 
   numbers representing the positions of literals after respective operations with respect to the original clause. 
   A computation ensures the operation is admissible:
   - In the case of permutations, all literals must still be present in the permuted clause.
   - In the case of double literal deletion, each literal must still be present at least once.
   If these conditions are fulfilled, the corresponding argument in the theorem will compute to `Ï€ âŠ¤` and can simply
   be instantiated with `âŠ¤áµ¢` (examples are given below).

---

** Defined Operations:
                        `x âˆˆâ‚™ l`: Special case of âˆˆ for natural numbers and equality relation `eqn`
                   `literal n l`: Returns the element of the list `l` of terms of type `o` at index `n`.
                 `literals ln l`: Takes as arguments a list `ln` of natural numbers and a list `l` of terms of 
                                  type `o` and returns a list of  the elements of `l` ordered according to the 
                                  indices in `ln`.
                        `disj l`: Returns the disjunction of all literals in the list `l`.
                      `l1 âŠ†â‚™ l2`: Special case of âŠ† for natural numbers and equality relation `eqn`
      `preserves_contents ln lo`: Takes a list of natural numbers (`ln`) and a list of terms of type `o` (`lo`) 
                                  as arguments. Returns `true` if every index of `lo` is included in `ln`.
*/

require open Stdlib.List Stdlib.PropExt;
  

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// lemmas ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Define some notations corresponding to standard library symbols

symbol âˆˆâ‚™ â‰” âˆˆ eqn;
notation âˆˆâ‚™ infix right 40;

symbol literal â‰” nth âŠ¥;
assert l0 l1 l2 âŠ¢ literal (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) 1 â‰¡ l1;

symbol literals â‰” nths âŠ¥;
assert l0 l1 l2 âŠ¢ literals (l0 â¸¬ l1 â¸¬ l2  â¸¬ l1 â¸¬ â–¡) (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) â‰¡ l1 â¸¬ (l2  â¸¬ (l0 â¸¬ (l1 â¸¬ â–¡)));


// n-ary disj

symbol disj : ğ•ƒ o â†’ Ï„ o;
rule disj ($l1 â¸¬ ($c â¸¬ $l)) â†ª ($l1 âˆ¨ disj ($c â¸¬ $l))
with disj ($l1 â¸¬ â–¡) â†ª $l1 
with disj â–¡ â†ª âŠ¥;

assert l0 l1 l2 âŠ¢ Ï€ (disj (l0 â¸¬ l1 â¸¬ l2  â¸¬ l1 â¸¬ â–¡)) â‰¡ Ï€ (l0 âˆ¨ (l1 âˆ¨ (l2  âˆ¨ l1)));

opaque symbol disj_head (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ l0 â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine h1}   
        {assume x0 l1 h1 h2; 
        refine âˆ¨áµ¢â‚ h2}
end; 

opaque symbol disj_tail (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (disj l) â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume x1 l1 h1 h2;
        refine âˆ¨áµ¢â‚‚ h2}
end;

opaque symbol disj_correct (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (disj (l0 â¸¬ l) = (l0 âˆ¨ disj l)) â‰”
begin
    assume l0;
    induction
        {simplify; 
        rewrite âˆ¨âŠ¥; 
        reflexivity}
        {simplify;
        assume x l h0; 
        reflexivity}
end;

opaque symbol disj_++_correct (l l' : ğ•ƒ o) : 
    Ï€ (disj (l ++ l') = (disj l âˆ¨ disj l')) â‰”
begin
    induction
        {simplify; assume x; 
        rewrite âŠ¥âˆ¨; reflexivity}
        {simplify; assume l0 l h0 l'; 
        rewrite disj_correct; rewrite disj_correct;
        rewrite h0 l'; rewrite âˆ¨_assoc;
        reflexivity}
end;

opaque symbol lit_imp_disj (c: ğ•ƒ o) (ks: ğ•ƒ nat) : 
    Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ ks) â†’ Ï€ (disj (literals c ks)) â‰”
begin
    assume c;
    induction
    {assume h1;
        have H0: Î  x: Ï„ nat, Ï€ ((Î» x1, literal c x1 âˆ§ âŠ¥) x) â†’ Ï€ âŠ¥
        {assume x h2;
        refine âˆ§â‚‘â‚‚ h2};
        refine âˆƒâ‚‘ h1 H0}
    {assume n l h1 h2;
        have H1: Î  x: Ï„ nat,
        Ï€ ((Î» x1, literal c x1 âˆ§ (eqn x1 n or x1 âˆˆâ‚™ l)) x)
            â†’ Ï€ (disj (literal c n â¸¬ literals c l))
        {assume m h3;
        have H0: Ï€ (eqn m n âˆ¨ m âˆˆâ‚™ l)
            {refine âˆ¨_istrue [eqn m n] [m âˆˆâ‚™ l] (âˆ§â‚‘â‚‚ h3)};
        have H1: Ï€ (eqn m n) â†’ Ï€ (disj (literal c n â¸¬ literals c l))
            {assume h4;
            have H1_0: Ï€ (literal c n)
                {have H1_0_0: Ï€ (n = m)
                {symmetry;
                refine eqn_correct m n h4};
                rewrite H1_0_0;
                refine âˆ§â‚‘â‚ h3};
            refine disj_head (literal c n) (literals c l) H1_0};
        have H2: Ï€ (m âˆˆâ‚™ l) â†’ Ï€ (disj (literal c n â¸¬ literals c l))
            {assume h4;
            have H2_0: Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ l)
                {have H2_0_0: Ï€ ((Î» x, literal c x âˆ§ x âˆˆâ‚™ l) m)
                {refine âˆ§áµ¢ (âˆ§â‚‘â‚ h3) h4};
                refine âˆƒáµ¢ m H2_0_0};
            refine disj_tail (literal c n) (literals c l) (h1 H2_0)};
        refine âˆ¨â‚‘ H0 H1 H2};
        refine âˆƒâ‚‘ h2 H1}
end;

opaque symbol disj_imp_lit (c: ğ•ƒ o) (ks: ğ•ƒ nat): 
    Ï€ (disj (literals c ks)) â†’ Ï€ (`âˆƒ (x : Ï„ nat), literal c x âˆ§ x âˆˆâ‚™ ks) â‰”
begin
    assume c;
    induction
    {assume h1;
        refine âŠ¥â‚‘ h1}
    {assume l0 ks h1 h2;
        have H0: Ï€ (literal c l0 âˆ¨ disj (literals c ks))
        {refine =â‡’ (disj_correct (literal c l0) (literals c ks)) h2};
        have H1: Ï€ (literal c l0) â†’ Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ (l0 â¸¬ ks))
        {assume h3;
        have H1_0: Ï€ (literal c l0)
            {refine h3};
        have H1_1: Ï€ ((Î» x, literal c x âˆ§ x âˆˆâ‚™ (l0 â¸¬ ks)) l0)
            {refine âˆ§áµ¢ H1_0
            (mem_head eqn l0 ks
                (istrue=true (eqn_complete l0 l0 (eq_refl l0))))};
        refine âˆƒáµ¢ l0 H1_1};
        have H2: Ï€ (disj (literals c ks)) â†’ Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ (l0 â¸¬ ks))
        {assume h3;
        have H2_0: Î  x: Ï„ nat,
            Ï€ ((Î» x1, literal c x1 âˆ§ x1 âˆˆâ‚™ ks) x)
                â†’ Ï€ (`âˆƒ x1, literal c x1 âˆ§ x1 âˆˆâ‚™ (l0 â¸¬ ks))
            {assume n h4;
            have H2_0_0: Ï€ ((Î» x, literal c x âˆ§ x âˆˆâ‚™ (l0 â¸¬ ks)) n)
                {refine âˆ§áµ¢ (âˆ§â‚‘â‚ h4) (mem_tail eqn n l0 ks (âˆ§â‚‘â‚‚ h4))};
            refine âˆƒáµ¢ n H2_0_0};
        refine âˆƒâ‚‘ (h1 h3) H2_0};
        refine âˆ¨â‚‘ H0 H1 H2}
end;   


// âŠ†

symbol âŠ†â‚™ â‰” âŠ† eqn;
notation âŠ†â‚™ infix right 30.000000;

assert âŠ¢ (0 â¸¬ 1 â¸¬ â–¡) âŠ†â‚™ (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) â‰¡ true;

opaque symbol âŠ†â‚™_el (n: Ï„ nat) (Ïƒ: ğ•ƒ nat) (ln: ğ•ƒ nat): 
    Ï€ (ln âŠ†â‚™ Ïƒ) â†’ Ï€ (n âˆˆâ‚™ ln) â†’ Ï€ (n âˆˆâ‚™ Ïƒ) â‰”
begin
    assume n Ïƒ;
    induction
    {assume h1 h2;
        refine âŠ¥â‚‘ h2}
    {assume m ln h1 h2 h3;
        have H1: Ï€ (eqn n m) â†’ Ï€ (n âˆˆâ‚™ Ïƒ)
        {assume h4;
        have H1_0: Ï€ (n = m)
            {refine eqn_correct n m h4};
        rewrite H1_0;
        refine andâ‚‘â‚ [âˆˆ eqn m Ïƒ] [âŠ† eqn ln Ïƒ] h2};
        have H2: Ï€ (n âˆˆâ‚™ ln) â†’ Ï€ (n âˆˆâ‚™ Ïƒ)
            {assume h4;
            refine h1 (andâ‚‘â‚‚ [âˆˆ eqn m Ïƒ] [âŠ† eqn ln Ïƒ] h2) h4};
        refine orâ‚‘ [eqn n m] [n âˆˆâ‚™ ln] (n âˆˆâ‚™ Ïƒ) h3 H1 H2}
end;


// preserves_contents

symbol preserves_contents: ğ•ƒ nat â†’ ğ•ƒ o â†’ ğ”¹;
rule preserves_contents  $f $l â†ª indexes $l âŠ†â‚™ $f;

assert l0 l1 l2 âŠ¢ 
    preserves_contents (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) â‰¡ true;

opaque symbol preserves_contents_correct (n: Ï„ nat) (Ïƒ : ğ•ƒ nat) (l: ğ•ƒ o) : 
    Ï€ (preserves_contents Ïƒ l) â†’  Ï€ (n âˆˆâ‚™ indexes l) â†’ Ï€ (n âˆˆâ‚™ Ïƒ) â‰”
begin
    assume n Ïƒ l h1 h2;
    refine âŠ†â‚™_el n Ïƒ (indexes l) h1 h2;   
end;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// meta-theorems ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

///////////////////// Natural Deduction rules over lists ///////////////////////

// âˆ¨áµ¢â‚™
opaque symbol âˆ¨áµ¢â‚™ (c0 : ğ•ƒ o) (c1 : ğ•ƒ o) (c2 : ğ•ƒ o) : 
    Ï€ (disj c1) â†’ Ï€ (disj (c0 ++ c1 ++ c2))â‰”
begin
    induction
        {assume x c2 h0; simplify;
        rewrite disj_++_correct; refine âˆ¨áµ¢â‚ h0}
        {assume x0 l h0 x1 x2 h1; simplify;  
        rewrite disj_correct; refine âˆ¨áµ¢â‚‚ (h0 x1 x2 h1)}
end;

// âˆ¨â‚‘â‚™ 
opaque symbol âˆ¨â‚‘â‚™ (n : â„•) (c : ğ•ƒ o) [r : Prop] : 
    Ï€ (disj c) â†’ Ï€ (literal c n â‡’ r) â†’ Ï€ (disj (rem_nth c n) â‡’ r) â†’ Ï€ r â‰”
begin
    induction
        {induction
            {assume x h0 h1 h2; refine âŠ¥â‚‘ h0}
            {assume l0 l h0 r h1 h2 h3;
             refine âˆ¨â‚‘ (=â‡’ (disj_correct l0 l) h1) _ _
                {assume h4; refine h2 h4}
                {assume h4; refine h3 h4}}}
        {assume n h0; induction
            {assume r h1 h2 h3; refine âŠ¥â‚‘ h1}
            {assume l0 l h1 r h2 h3 h4;
            have H1 : Ï€ ((l0  âˆ¨ (disj (rem_nth l n))) â‡’ r)
                    {rewrite left disj_correct; refine h4};
            refine âˆ¨â‚‘ (em l0) _ _
                {assume h5;
                refine H1 ((âˆ¨áµ¢â‚ [l0] [disj (rem_nth l n)]) h5)}
                {assume h5;
                have l0isâŠ¥ : Ï€ (âŠ¥ = l0)
                    {refine propExt âŠ¥ l0 _ _
                        {assume h6; refine âŠ¥â‚‘ h6}
                         {assume h6; refine h5 h6}};
                refine h0 l r _ h3 _
                    {rewrite left âŠ¥âˆ¨; rewrite l0isâŠ¥;
                    rewrite left disj_correct l0 l; refine h2}
                    {rewrite left âŠ¥âˆ¨ (disj (rem_nth l n)); 
                    rewrite l0isâŠ¥; refine H1}}}}        
end;


// permutation theorem /////////////////////////////////////////////////////////
opaque symbol permute (Ïƒ : ğ•ƒ nat) (c: ğ•ƒ o) : 
    Ï€ (preserves_contents Ïƒ c) â†’ Ï€(disj c) â†’ Ï€(disj (literals c Ïƒ)) â‰”
begin
    assume Ïƒ c h1 h2;
    have H1: Î  x: Ï„ nat,
        Ï€ ((Î» x1, literal c x1 âˆ§ x1 âˆˆâ‚™ indexes c) x)
        â†’ Ï€ (`âˆƒ y, literal c y âˆ§ y âˆˆâ‚™ Ïƒ)
        {assume x0 h3;
        refine âˆƒáµ¢ x0 (âˆ§áµ¢ (âˆ§â‚‘â‚ h3) (preserves_contents_correct x0 Ïƒ c h1 (âˆ§â‚‘â‚‚ h3)))};
    have H2: Ï€ (`âˆƒ y, literal c y âˆ§ y âˆˆâ‚™ Ïƒ)
        {have H3: Ï€ (disj (nths âŠ¥ c (indexes c)))
            {rewrite nths_indexes_id âŠ¥ c;
            refine h2};
        refine âˆƒâ‚‘ (disj_imp_lit c (indexes c) H3) H1};
    refine lit_imp_disj c Ïƒ H2
end;

assert l0 l1 l2 âŠ¢ permute (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ l0 â¸¬ â–¡) âŠ¤áµ¢ : 
    Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l0) â†’ Ï€ (l1 âˆ¨ l2 âˆ¨ l0 âˆ¨ l0);


// double literal deletion theorem /////////////////////////////////////////////
opaque symbol delete (id_list : ğ•ƒ nat) (output_list : ğ•ƒ nat) (c: ğ•ƒ o) : 
    Ï€ (id_list âŠ†â‚™ output_list) â†’ Ï€(disj (literals c id_list)) â†’ Ï€(disj (literals c output_list)) â‰”
begin
    assume id_list output_list c h1 h2;
    refine lit_imp_disj c output_list _;
    refine âˆƒâ‚‘ (disj_imp_lit c id_list h2) _;
    assume n h3;
    refine âˆƒáµ¢ n (âˆ§áµ¢ (âˆ§â‚‘â‚ h3)
        (âŠ†â‚™_el n output_list id_list h1 (âˆ§â‚‘â‚‚ h3)))
end; 

assert l0 l1 l2 âŠ¢ delete (0 â¸¬ 1 â¸¬ 0 â¸¬ 0 â¸¬ 2 â¸¬ â–¡) (0 â¸¬ 1 â¸¬ 2 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ â–¡) âŠ¤áµ¢: 
    Ï€ (l0 âˆ¨ l1 âˆ¨ l0 âˆ¨ l0 âˆ¨ l2) â†’ Ï€ (l0 âˆ¨ l1 âˆ¨ l2);

    
opaque symbol deleteDoubles (id_list : ğ•ƒ nat) (c: ğ•ƒ o) : 
    Ï€(disj (literals c id_list)) â†’ Ï€(disj (literals c (undup_first eqn id_list))) â‰”
begin
    assume id_list c h2;
    refine delete id_list (undup_first eqn id_list) c (subset_undup_first eqn eqn_correct eqn_refl eqn_sym id_list) h2;
end; 

assert l0 l1 l2 âŠ¢ deleteDoubles (0 â¸¬ 1 â¸¬ 0 â¸¬ 0 â¸¬ 2 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ â–¡): 
    Ï€ (l0 âˆ¨ l1 âˆ¨ l0 âˆ¨ l0 âˆ¨ l2) â†’ Ï€ (l0 âˆ¨ l1 âˆ¨ l2);


// transformation theorem //////////////////////////////////////////////////////
opaque symbol transform [l : Ï„ o] (c: ğ•ƒ o) (n : Ï„ nat) : 
Ï€ (literal c n â‡’ l) â†’ Ï€ (disj c) â†’ Ï€ (disj (set_nth âŠ¥ c n l)) â‰”
begin
    assume l;
    induction
    {assume x h1 h2;
        refine âŠ¥â‚‘ h2}
    {assume x clause h1;
        induction
            {assume h2 h3;
            have H0: Ï€ (x âˆ¨ disj clause)
                {refine =â‡’ (disj_correct x clause) h3};
            have H1: Ï€ x â†’ Ï€ (disj (l â¸¬ clause))
                {assume h4;
                refine disj_head l clause (h2 h4)};
            have H2: Ï€ (disj clause) â†’ Ï€ (disj (l â¸¬ clause))
                {assume h4;
                refine disj_tail l clause h4};
            refine âˆ¨â‚‘ H0 H1 H2}
            {assume n h2 h3 h4;
            have H00: Ï€ (x âˆ¨ disj clause)
                {refine =â‡’ (disj_correct x clause) h4};
            have H10: Ï€ x â†’ Ï€ (disj (x â¸¬ set_nth âŠ¥ clause n l))
                {assume h5;
                refine disj_head x (set_nth âŠ¥ clause n l) h5};
            have H20: Ï€ (disj clause) â†’ Ï€ (disj (x â¸¬ set_nth âŠ¥ clause n l))
                {assume h5;
                have H2_0: Ï€ (disj (set_nth âŠ¥ clause n l))
                    {refine h1 n h3 h5};
                refine disj_tail x (set_nth âŠ¥ clause n l) H2_0};
            refine âˆ¨â‚‘ H00 H10 H20}}
end;

assert l0 l1 l2 l2' âŠ¢ transform [l2'] (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) 2 : 
    (Ï€ l2 â†’ Ï€ l2') â†’  Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1) â†’ Ï€ (l0 âˆ¨ l1 âˆ¨ l2' âˆ¨ l1);