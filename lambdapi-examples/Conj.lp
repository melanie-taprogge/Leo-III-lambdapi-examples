/* Library on Meta-Theorems for Conjunctions

-------------------

Note that this file has been added to the standard library. 
It has been included here for the sake of self-containment.

The library proves the following meta-theorems:

** n-ary Natural Deduction rules:
   - âˆ§áµ¢â‚™ is the n-ary version of the introduction rule for âˆ§.
   - âˆ§â‚‘â‚™ is the n-ary version of the elimination rule for âˆ§.

---

** Defined Operations:
           `x âˆˆâ‚™ l`: Special case of âˆˆ for natural numbers and equality relation `eqn`
       `clause n l`: Returns the element of the list `l` of terms of type `o` at index `n`.
           `conj l`: Returns the conjunction of all terms of type `o` in the list `l`.
*/

require open Stdlib.List Stdlib.PropExt;

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// lemmas ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Define some notations corresponding to standard library symbols
symbol âˆˆâ‚™ â‰” âˆˆ eqn;
notation âˆˆâ‚™ infix right 40;

symbol clause â‰” nth âŠ¥;

opaque symbol clause_ext (l: ğ•ƒ o) (l0 : Ï„ o) (n: Ï„ nat) : 
    Ï€ (clause l n) â†’ Ï€ (clause (l0 â¸¬ l) (n +1)) â‰”
begin
    assume l l0 n h1;
    refine h1
end;


// n-ary conjunction

symbol conj : ğ•ƒ o â†’ Ï„ o;
rule conj ($l1 â¸¬ ($c â¸¬ $l)) â†ª $l1 âˆ§ conj ($c â¸¬ $l)
with conj ($l1 â¸¬ â–¡) â†ª $l1 
with conj â–¡ â†ª âŠ¤;

assert l0 l1 l2 âŠ¢ Ï€ (conj (l0 â¸¬ l1 â¸¬ l2  â¸¬ l1 â¸¬ â–¡)) â‰¡ Ï€ (l0 âˆ§ (l1 âˆ§ (l2  âˆ§ l1)));

opaque symbol conj_head (c0 : Ï„ o) (c : ğ•ƒ o) : 
     Ï€ (conj (c0 â¸¬ c)) â†’ Ï€ c0 â‰”
begin
    assume c0;
    induction
        {assume h1;
        refine h1}   
        {assume x0 c1 h1 h2;
        refine âˆ§â‚‘â‚ h2}
end; 

opaque symbol conj_tail (c0 : Ï„ o) (c : ğ•ƒ o) : 
     Ï€ (conj (c0 â¸¬ c)) â†’ Ï€ (conj c) â‰”
begin
    assume c0;
    induction
        {assume h1;
        refine âŠ¤áµ¢}   
        {assume x0 c1 h1 h2; 
        refine âˆ§â‚‘â‚‚ h2}
end; 

opaque symbol conj_correct (c0 : Ï„ o) (c : ğ•ƒ o) : 
    Ï€ (conj (c0 â¸¬ c)) â†’ Ï€ (c0 âˆ§ conj c) â‰”
begin
    assume c0;
    induction
        {assume h1;
        refine âˆ§áµ¢ h1 âŠ¤áµ¢}
        {assume x1 c1 h1 h2;
        refine h2}
end;

opaque symbol conj_sound (c0 : Ï„ o) (c : ğ•ƒ o) : 
    Ï€ (c0 âˆ§ conj c) â†’  Ï€ (conj (c0 â¸¬ c)) â‰”
begin
    assume c0;
    induction
        {assume h1; refine âˆ§â‚‘â‚ h1}
        {assume x1 c1 h1 h2; refine h2}
end;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// meta-theorems ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// âˆ§áµ¢â‚™ 
opaque symbol âˆ§áµ¢â‚™ (c0 : ğ•ƒ o) (c1 : ğ•ƒ o) : 
    Ï€ (conj c0) â†’ Ï€ (conj c1) â†’ Ï€ (conj (c0 ++ c1))â‰”
begin
    induction
        {assume x h0 h1;
        refine h1}
        {assume x0 l0 h0 l1 h1 h2;
        refine conj_sound x0 (l0 ++ l1) _;
        refine âˆ§áµ¢ _ _
            {refine conj_head x0 l0 h1}
            {refine h0 l1 (conj_tail x0 l0 h1) h2}}
end;

// âˆ§â‚‘â‚™ 
opaque symbol âˆ§â‚‘â‚™ (id : Ï„ nat) (cnf: ğ•ƒ o) : 
    Ï€ (id âˆˆâ‚™ indexes cnf) â†’ Ï€ (conj cnf) â†’ Ï€ (clause cnf id) â‰”
begin
    induction 
        {induction
            {assume h0 h1; refine h0}
            {assume x cnf h0 h1 h2; 
            refine conj_head x cnf h2}}
        {assume id h0;
        induction
            {assume b; refine âŠ¥â‚‘ b}
            {assume x cnf h1 h2 h3;
            have ConjImpCl : Ï€ (conj cnf â‡’ clause cnf id)
                {refine h0 cnf (indexes_decrement id x cnf h2)};
            refine clause_ext cnf x id (ConjImpCl (conj_tail x cnf h3))}}
end;